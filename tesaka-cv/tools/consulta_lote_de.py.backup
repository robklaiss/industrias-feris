#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Consulta estado de Lote en SIFEN (async) a partir de dProtConsLote.

Uso:
  python -m tools.consulta_lote_de --env test --prot 47353168697315928
Requiere:
  export SIFEN_CERT_PATH="/ruta/al/cert.p12"
  export SIFEN_CERT_PASSWORD="TU_PASSWORD" (o se pedir√° interactivamente)
"""

from __future__ import annotations

# SOAP 1.2 action para Consulta Lote (fallback manual)
SIFEN_CONS_LOTE_ACTION = "rEnviConsLoteDe"
import argparse
import getpass
import json
import os
import re
import subprocess
import sys
import tempfile
from datetime import datetime

# Helper: asegurar bytes (evita write_bytes(_ensure_bytes(None)))
def _ensure_bytes(x):
    if x is None:
        return b""
    if isinstance(x, (bytes, bytearray)):
        return bytes(x)
    if isinstance(x, str):
        return x.encode("utf-8", "ignore")
    return str(x).encode("utf-8", "ignore")


# dId requerido por SIFEN (15 d√≠gitos tipo YYYYMMDDHHMMSSmmm)
def _make_did() -> str:
    return datetime.now().strftime('%Y%m%d%H%M%S%f')[:15]

from pathlib import Path
from typing import Any, Dict, Optional, List
from urllib.parse import urljoin, urlparse

# Agregar el directorio padre al path para imports
sys.path.insert(0, str(Path(__file__).parent.parent))

try:
    import lxml.etree as etree  # noqa: F401
except ImportError:
    print("‚ùå Error: lxml no est√° instalado", file=sys.stderr)
    print("   Instale con: pip install lxml", file=sys.stderr)
    sys.exit(1)

try:
    from zeep import Client, Settings
    from zeep.transports import Transport
    from zeep.exceptions import Fault, TransportError
    from zeep.helpers import serialize_object
    from zeep.plugins import HistoryPlugin
    from zeep.wsdl.bindings.soap import Soap12Binding, Soap11Binding
    from zeep.cache import InMemoryCache
    import logging
    ZEEP_AVAILABLE = True
except ImportError:
    ZEEP_AVAILABLE = False
    print("‚ùå Error: zeep no est√° instalado", file=sys.stderr)
    print("   Instale con: pip install zeep", file=sys.stderr)
    sys.exit(1)

try:
    from app.sifen_client.config import (
        get_sifen_config,
        get_mtls_config,
    )
    from app.sifen_client.exceptions import SifenClientError
    from app.sifen_client.pkcs12_utils import p12_to_temp_pem_files, PKCS12Error
except ImportError as e:
    print(f"‚ùå Error: No se pudo importar m√≥dulos SIFEN: {e}", file=sys.stderr)
    print("   Aseg√∫rate de que las dependencias est√©n instaladas:", file=sys.stderr)
    print("   Instale con: pip install -r requirements.txt", file=sys.stderr)
    print("   pip install zeep lxml cryptography requests", file=sys.stderr)
    sys.exit(1)

from requests import Session
from requests.adapters import HTTPAdapter
try:
    from urllib3.util.retry import Retry
    URLLIB3_RETRY_AVAILABLE = True
except ImportError:
    URLLIB3_RETRY_AVAILABLE = False


def resolve_p12_password(args: argparse.Namespace) -> str:
    """
    Resuelve la contrase√±a P12 desde m√∫ltiples fuentes en orden de prioridad.
    
    Orden de b√∫squeda:
    1. Argumento CLI --p12-password (si est√° presente)
    2. SIFEN_MTLS_P12_PASSWORD
    3. SIFEN_CERT_PASSWORD
    4. SIFEN_SIGN_P12_PASSWORD
    5. MTLS_P12_PASSWORD (compatibilidad)
    6. CERT_PASSWORD (compatibilidad)
    7. Si hay TTY: pedir con getpass
    8. Si no hay TTY: lanzar error claro
    
    Args:
        args: Argumentos parseados (debe tener atributo p12_password opcional)
        
    Returns:
        Contrase√±a como string
        
    Raises:
        SystemExit: Si no se encuentra contrase√±a y no hay TTY
    """
    # 1) Argumento CLI
    if hasattr(args, "p12_password") and args.p12_password:
        pwd = str(args.p12_password).strip()
        if pwd:
            return pwd
    
    # 2-6) Variables de entorno en orden de prioridad
    env_vars = [
        "SIFEN_MTLS_P12_PASSWORD",
        "SIFEN_CERT_PASSWORD",
        "SIFEN_SIGN_P12_PASSWORD",
        "MTLS_P12_PASSWORD",
        "CERT_PASSWORD",
    ]
    
    for env_var in env_vars:
        pwd = os.getenv(env_var, "").strip()
        if pwd:
            return pwd
    
    # 7) Si hay TTY, pedir interactivamente
    if sys.stdin.isatty():
        try:
            pwd = getpass.getpass("üîê Contrase√±a del certificado P12: ")
            if pwd and pwd.strip():
                return pwd.strip()
        except (EOFError, KeyboardInterrupt):
            print("\n‚ùå Operaci√≥n cancelada.", file=sys.stderr)
            sys.exit(1)
    
    # 8) No hay TTY y no se encontr√≥ contrase√±a
    _die(
        "Contrase√±a requerida: setear SIFEN_MTLS_P12_PASSWORD o SIFEN_CERT_PASSWORD "
        "(o usar --p12-password en modo interactivo)"
    )


def cleanup_pem_files(cert_path=None, key_path=None):
    """Limpia archivos PEM temporales (par√°metros opcionales)."""
    for p in (cert_path, key_path):
        try:
            if p and os.path.exists(p):
                os.remove(p)
        except Exception:
            pass


def _artifact_bytes_from(obj: Any) -> tuple[bytes, str]:
    """
    Convierte un objeto a bytes XML para guardar en artifacts.
    
    Retorna (payload_bytes, ext) donde ext es ".xml" si es XML real o ".txt" si es fallback.
    
    Args:
        obj: Objeto a convertir (lxml Element/ElementTree, bytes, str, u otro)
        
    Returns:
        Tupla (bytes, extensi√≥n)
    """
    if obj is None:
        return (b"", ".txt")
    
    try:
        from lxml import etree
        
        # lxml ElementTree / Element
        if isinstance(obj, etree._ElementTree):
            root = obj.getroot()
            b = etree.tostring(root, xml_declaration=True, encoding="UTF-8", pretty_print=True)
            return (b, ".xml")
        
        if isinstance(obj, etree._Element):
            b = etree.tostring(obj, xml_declaration=True, encoding="UTF-8", pretty_print=True)
            return (b, ".xml")
        
        # bytes / str
        if isinstance(obj, (bytes, bytearray)):
            bytes_obj = bytes(obj)
            return (bytes_obj, ".xml" if b"<" in bytes_obj[:50] else ".txt")
        
        if isinstance(obj, str):
            bb = obj.encode("utf-8", errors="replace")
            return (bb, ".xml" if "<" in obj[:50] else ".txt")
        
        # fallback
        return (repr(obj).encode("utf-8", errors="replace"), ".txt")
    except Exception:
        # Si falla cualquier conversi√≥n, usar repr como √∫ltimo recurso
        return (repr(obj).encode("utf-8", errors="replace"), ".txt")


def fetch_wsdl_to_file(wsdl_url: str, session: Session, artifacts_dir: Optional[Path], debug: bool = False) -> Path:
    """
    Descarga el WSDL a un archivo local, evitando compresi√≥n que puede causar body vac√≠o.
    
    Args:
        wsdl_url: URL del WSDL
        session: requests.Session con mTLS configurado
        artifacts_dir: Directorio para guardar artifacts (None = usar /tmp)
        debug: Si True, imprime informaci√≥n de debug
        
    Returns:
        Path al archivo WSDL descargado
        
    Raises:
        RuntimeError: Si el WSDL est√° vac√≠o o no se puede descargar
    """
    # Configurar headers para evitar compresi√≥n
    headers = {
        "Accept": "text/xml,*/*",
        "Accept-Encoding": "identity",
        "User-Agent": "tesaka-cv consulta_lote_de"
    }
    
    # Intentar descargar WSDL
    try:
        response = session.get(wsdl_url, headers=headers, timeout=30)
    except Exception as e:
        raise RuntimeError(f"Error al descargar WSDL desde {wsdl_url}: {e}") from e
    
    content = response.content
    is_empty = not content or not content.strip()
    
    # Si est√° vac√≠o, intentar URL alternativa
    if is_empty:
        alt_url = None
        if "?wsdl" in wsdl_url:
            alt_url = wsdl_url.replace("?wsdl", "")
        else:
            alt_url = wsdl_url + "?wsdl"
        
        if alt_url:
            try:
                print(f"‚ö†Ô∏è  WSDL vac√≠o desde {wsdl_url}, intentando alternativa: {alt_url}")
                response = session.get(alt_url, headers=headers, timeout=30)
                content = response.content
                is_empty = not content or not content.strip()
                wsdl_url = alt_url  # Usar la URL alternativa para mensajes de error
            except Exception as e:
                pass  # Continuar con el error original
    
    # Si sigue vac√≠o, guardar artifacts de debug y fallar
    if is_empty:
        if artifacts_dir:
            artifacts_dir.mkdir(exist_ok=True)
            # Guardar headers
            headers_file = artifacts_dir / "wsdl_fail.headers.txt"
            with headers_file.open("w", encoding="utf-8") as f:
                f.write(f"URL: {wsdl_url}\n")
                f.write(f"Status Code: {response.status_code}\n")
                f.write(f"Content-Length: {len(content)}\n")
                f.write("\n--- Response Headers ---\n")
                for key, value in response.headers.items():
                    f.write(f"{key}: {value}\n")
            
            # Guardar body (aunque est√© vac√≠o)
            body_file = artifacts_dir / "wsdl_fail.body.bin"
            body_file.write_bytes(_ensure_bytes(content))
            
            print(f"üíæ Artifacts guardados: {headers_file.name}, {body_file.name}")
        
        content_encoding = response.headers.get("Content-Encoding", "none")
        raise RuntimeError(
            f"WSDL vac√≠o (HTTP={response.status_code}, url={wsdl_url}, "
            f"content-encoding={content_encoding}, content-length={len(content)})"
        )
    
    # Guardar WSDL en archivo local
    if artifacts_dir:
        artifacts_dir.mkdir(exist_ok=True)
        wsdl_file = artifacts_dir / "consulta-lote.wsdl.xml"
    else:
        # Usar archivo temporal
        fd, temp_path = tempfile.mkstemp(suffix=".wsdl.xml", prefix="consulta_lote_", delete=False)
        os.close(fd)
        wsdl_file = Path(temp_path)
    
    wsdl_file.write_bytes(_ensure_bytes(content))
    
    if debug:
        print(f"üíæ WSDL descargado a: {wsdl_file}")
    
    return wsdl_file


def mtls_download(url: str, out_path: Path, cert_path: str, key_or_password: str, is_pem_mode: bool, cache_dir: Path, debug: bool) -> None:
    """
    Descarga un archivo usando curl con mTLS (certificado PEM o P12).
    
    Args:
        url: URL a descargar
        out_path: Path donde guardar el archivo
        cert_path: Ruta al certificado (PEM o P12)
        key_or_password: Ruta a la clave (PEM) o contrase√±a (P12)
        is_pem_mode: True para modo PEM, False para modo P12
        cache_dir: Directorio para guardar logs de error
        debug: Si True, imprime informaci√≥n de debug
        
    Raises:
        RuntimeError: Si la descarga falla o el contenido est√° vac√≠o
    """
    # Construir comando curl seg√∫n modo
    cmd = [
        "curl",
        "-sS",  # Silent pero muestra errores
        "-L",  # Follow redirects
        "--http1.1",  # Forzar HTTP/1.1
        "-H", "Accept-Encoding: identity",  # Sin compresi√≥n
    ]
    
    if is_pem_mode:
        # MODO PEM
        cmd.extend([
            "--cert-type", "PEM",
            "--key-type", "PEM",
            "--cert", cert_path,
            "--key", key_or_password,
        ])
        debug_cert_display = f"--cert {cert_path} --key {key_or_password}"
    else:
        # MODO P12
        cmd.extend([
            "--cert-type", "P12",
            "--cert", f"{cert_path}:{key_or_password}",
        ])
        debug_cert_display = f"--cert {cert_path}:***"
    
    cmd.append(url)
    
    if debug:
        print(f"üîΩ Descargando: {url}")
        print(f"   Comando: curl ... {debug_cert_display}")
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=60,
            check=False  # No lanzar excepci√≥n autom√°ticamente
        )
        
        content = result.stdout
        
        # Si est√° vac√≠o, guardar trace y headers
        if not content or not content.strip():
            cache_dir.mkdir(exist_ok=True)
            headers_file = out_path.with_suffix(".headers.txt")
            trace_file = out_path.with_suffix(".trace.txt")
            
            with headers_file.open("w", encoding="utf-8") as f:
                f.write(f"URL: {url}\n")
                f.write(f"Exit Code: {result.returncode}\n")
                f.write(f"Content Length: {len(content)}\n")
                if result.stderr:
                    f.write(f"\n--- stderr ---\n{result.stderr.decode('utf-8', errors='ignore')}\n")
            
            with trace_file.open("w", encoding="utf-8") as f:
                f.write(f"Command: {' '.join(cmd[:6])} ... --cert ***\n")
                f.write(f"Return Code: {result.returncode}\n")
                f.write(f"stdout length: {len(content)}\n")
                if result.stderr:
                    f.write(f"\nstderr:\n{result.stderr.decode('utf-8', errors='ignore')}\n")
            
            print(f"üíæ Artifacts guardados: {headers_file.name}, {trace_file.name}")
            raise RuntimeError(f"WSDL vac√≠o al descargar con mTLS (url={url}, exit_code={result.returncode})")
        
        # Guardar contenido
        out_path.parent.mkdir(parents=True, exist_ok=True)
        out_path.write_bytes(_ensure_bytes(content))
        
        if debug:
            print(f"‚úÖ Descargado: {out_path} ({len(content)} bytes)")
    
    except subprocess.TimeoutExpired:
        raise RuntimeError(f"Timeout al descargar {url} con curl")
    except Exception as e:
        raise RuntimeError(f"Error al descargar {url} con curl: {e}") from e


def resolve_xsd_imports(wsdl_path: Path, wsdl_url: str, cache_dir: Path, cert_path: str, key_or_password: str, is_pem_mode: bool, debug: bool) -> None:
    """
    Resuelve e descarga imports XSD relativos del WSDL.
    
    Args:
        wsdl_path: Path al archivo WSDL local
        wsdl_url: URL original del WSDL (para construir URLs absolutas)
        cache_dir: Directorio donde guardar XSDs descargados
        cert_path: Ruta al certificado (PEM o P12) para mTLS
        key_or_password: Ruta a la clave (PEM) o contrase√±a (P12)
        is_pem_mode: True para modo PEM, False para modo P12
        debug: Si True, imprime informaci√≥n de debug
    """
    try:
        wsdl_content = wsdl_path.read_text(encoding="utf-8", errors="ignore")
    except Exception as e:
        if debug:
            print(f"‚ö†Ô∏è  No se pudo leer WSDL para resolver imports: {e}")
        return
    
    # Buscar schemaLocation en imports e includes
    # Patrones: schemaLocation="...", schemaLocation='...', xsd:schemaLocation="..."
    pattern = r'(?:xsd:)?schemaLocation\s*=\s*["\']([^"\']+)["\']'
    matches = re.findall(pattern, wsdl_content, re.IGNORECASE)
    
    if not matches:
        if debug:
            print("‚ÑπÔ∏è  No se encontraron imports XSD en el WSDL")
        return
    
    # Base URL para imports relativos
    base_url = wsdl_url.rsplit("/", 1)[0] + "/"
    
    for schema_location in matches:
        # Si es URL absoluta, saltarla (ya est√° en internet)
        if schema_location.startswith(("http://", "https://")):
            if debug:
                print(f"‚è≠Ô∏è  Saltando import absoluto: {schema_location}")
            continue
        
        # Construir URL completa
        full_url = urljoin(base_url, schema_location)
        
        # Nombre del archivo destino (basename del schemaLocation)
        xsd_filename = os.path.basename(schema_location)
        if not xsd_filename:
            xsd_filename = "imported.xsd"
        
        # Agregar prefijo para evitar colisiones
        target_path = cache_dir / f"consulta-lote.wsdl.{xsd_filename}"
        
        # Si ya existe y no est√° vac√≠o, saltarlo
        if target_path.exists() and target_path.stat().st_size > 0:
            if debug:
                print(f"‚úÖ XSD ya existe en cache: {target_path.name}")
            continue
        
        # Descargar XSD
        try:
            if debug:
                print(f"üì• Descargando XSD: {schema_location} -> {target_path.name}")
            mtls_download(full_url, target_path, cert_path, key_or_password, is_pem_mode, cache_dir, debug)
        except Exception as e:
            if debug:
                print(f"‚ö†Ô∏è  No se pudo descargar XSD {schema_location}: {e}")
            # Continuar con otros imports aunque uno falle
            # El XSD es opcional - no abortar si no se puede descargar


def load_wsdl_source(wsdl_url: str, cache_dir: Path, wsdl_file: Optional[Path], cert_path: str, key_or_password: str, is_pem_mode: bool, debug: bool) -> Path:
    """
    Resuelve el origen del WSDL: archivo provisto, cache, o descarga remota.
    
    Args:
        wsdl_url: URL del WSDL (para descarga si es necesario)
        cache_dir: Directorio de cache
        wsdl_file: Archivo WSDL provisto por usuario (opcional)
        cert_path: Ruta al certificado (PEM o P12) para mTLS
        key_or_password: Ruta a la clave (PEM) o contrase√±a (P12)
        is_pem_mode: True para modo PEM, False para modo P12
        debug: Si True, imprime informaci√≥n de debug
        
    Returns:
        Path al archivo WSDL local
        
    Raises:
        RuntimeError: Si el archivo no existe o est√° vac√≠o
    """
    # Caso 1: Archivo provisto expl√≠citamente
    if wsdl_file:
        wsdl_path = Path(wsdl_file)
        if not wsdl_path.exists():
            raise RuntimeError(f"Archivo WSDL no encontrado: {wsdl_path}")
        if wsdl_path.stat().st_size == 0:
            raise RuntimeError(f"Archivo WSDL est√° vac√≠o: {wsdl_path}")
        if debug:
            print(f"üìÇ Usando WSDL provisto: {wsdl_path}")
        return wsdl_path
    
    # Caso 2: Verificar cache
    cache_dir.mkdir(parents=True, exist_ok=True)
    cached = cache_dir / "consulta-lote.wsdl.xml"
    
    if cached.exists() and cached.stat().st_size > 0:
        if debug:
            print(f"üíæ Usando WSDL en cache: {cached}")
        return cached
    
    # Caso 3: Descargar desde remoto
    if debug:
        print(f"üåê Descargando WSDL desde: {wsdl_url}")
    
    try:
        mtls_download(wsdl_url, cached, cert_path, key_or_password, is_pem_mode, cache_dir, debug)
    except Exception as e:
        raise RuntimeError(f"Error al descargar WSDL: {e}") from e
    
    # Resolver imports XSD relativos (opcional - no aborta si falla)
    try:
        resolve_xsd_imports(cached, wsdl_url, cache_dir, cert_path, key_or_password, is_pem_mode, debug)
    except Exception as e:
        if debug:
            print(f"‚ö†Ô∏è  Error resolviendo imports XSD (continuando sin ellos): {e}")
        # Los XSDs son opcionales - continuar aunque no se resuelvan
    
    return cached


def _die(msg: str, code: int = 2) -> None:
    """Imprime mensaje de error y termina el programa."""
    print(f"‚ùå {msg}", file=sys.stderr)
    raise SystemExit(code)


def _apply_mtls_to_cli_config(config) -> None:
    """
    Normaliza mTLS para CLI (consulta_ruc / consulta_lote):
    - PEM: config.cert_path + config.key_path
    - P12: config.cert_path + config.cert_password
    """
    cert_path, key_or_password, is_pem_mode = get_mtls_config()

    config.cert_path = cert_path
    if is_pem_mode:
        config.key_path = key_or_password
        config.cert_password = None
    else:
        config.key_path = None
        config.cert_password = key_or_password

    # opcional, por si el config lo tiene
    if hasattr(config, "is_pem_mode"):
        config.is_pem_mode = is_pem_mode


def force_env_from_args(env: str) -> None:
    """
    Fuerza el ambiente desde los argumentos CLI.
    
    Esta funci√≥n asegura que si el usuario pasa --env, este siempre mande
    sobre cualquier SIFEN_ENV heredado del shell. Esto previene la regresi√≥n
    donde SIFEN_ENV=prod + --env test => error 0160.
    
    Args:
        env: Ambiente desde args.env ('test' o 'prod')
    """
    if env:
        os.environ["SIFEN_ENV"] = str(env)


def get_cdcs_for_lote(dprot_cons_lote: str, artifacts_dir: Path, debug: bool = False) -> List[str]:
    """
    Obtiene los CDCs (C√≥digos de Control) de un lote desde m√∫ltiples fuentes.
    
    Prioridad:
    1. Base de datos (si existe tabla de lotes/documentos)
    2. JSON guardado en artifacts/ (consulta_lote_*.json o lote_enviado_*.json)
    3. Si no hay nada, retorna lista vac√≠a
    
    Args:
        dprot_cons_lote: dProtConsLote (n√∫mero de lote)
        artifacts_dir: Directorio de artifacts
        debug: Si True, imprime informaci√≥n de debug
        
    Returns:
        Lista de CDCs (strings)
    """
    cdcs = []
    
    # 1. Intentar desde base de datos (si existe)
    try:
        # Buscar m√≥dulo de base de datos
        sys.path.insert(0, str(Path(__file__).parent.parent))
        try:
            from web import db
            if hasattr(db, 'get_cdcs_for_lote'):
                cdcs = db.get_cdcs_for_lote(dprot_cons_lote)
                if cdcs and debug:
                    print(f"üìä CDCs obtenidos desde BD: {len(cdcs)}")
                if cdcs:
                    return cdcs
        except (ImportError, AttributeError):
            pass  # No hay BD o no tiene el m√©todo
    except Exception as e:
        if debug:
            print(f"‚ö†Ô∏è  Error al buscar CDCs en BD: {e}")
    
    # 2. Intentar desde JSON en artifacts
    artifacts_dir.mkdir(exist_ok=True)
    
    # Buscar archivos JSON relacionados con el lote
    json_patterns = [
        f"consulta_lote_*.json",
        f"lote_enviado_*.json",
        f"*lote*{dprot_cons_lote}*.json",
    ]
    
    for pattern in json_patterns:
        json_files = list(artifacts_dir.glob(pattern))
        # Ordenar por mtime (m√°s reciente primero)
        json_files.sort(key=lambda p: p.stat().st_mtime, reverse=True)
        
        for json_file in json_files[:5]:  # Revisar solo los 5 m√°s recientes
            try:
                data = json.loads(json_file.read_text(encoding="utf-8"))
                
                # Buscar CDCs en diferentes estructuras posibles
                # Estructura 1: gResProcLote con id
                if "gResProcLote" in data:
                    g_res = data["gResProcLote"]
                    if isinstance(g_res, list):
                        for item in g_res:
                            if isinstance(item, dict):
                                cdc = item.get("id") or item.get("dId") or item.get("Id") or item.get("cdc") or item.get("CDC")
                                if cdc and cdc not in cdcs:
                                    cdcs.append(str(cdc))
                
                # Estructura 2: response_dict con gResProcLote
                if "response_dict" in data:
                    resp_dict = data["response_dict"]
                    if isinstance(resp_dict, dict) and "gResProcLote" in resp_dict:
                        g_res = resp_dict["gResProcLote"]
                        if isinstance(g_res, list):
                            for item in g_res:
                                if isinstance(item, dict):
                                    cdc = item.get("id") or item.get("dId") or item.get("Id") or item.get("cdc") or item.get("CDC")
                                    if cdc and cdc not in cdcs:
                                        cdcs.append(str(cdc))
                
                # Estructura 3: cdcs directo en el JSON
                if "cdcs" in data:
                    cdcs_list = data["cdcs"]
                    if isinstance(cdcs_list, list):
                        for cdc in cdcs_list:
                            if cdc and str(cdc) not in cdcs:
                                cdcs.append(str(cdc))
                
                # Estructura 4: documentos con Id
                if "documentos" in data:
                    docs = data["documentos"]
                    if isinstance(docs, list):
                        for doc in docs:
                            if isinstance(doc, dict):
                                cdc = doc.get("id") or doc.get("dId") or doc.get("Id") or doc.get("cdc") or doc.get("CDC")
                                if cdc and cdc not in cdcs:
                                    cdcs.append(str(cdc))
                
                if cdcs and debug:
                    print(f"üìÑ CDCs obtenidos desde {json_file.name}: {len(cdcs)}")
                    break
                    
            except Exception as e:
                if debug:
                    print(f"‚ö†Ô∏è  Error al leer {json_file.name}: {e}")
                continue
        
        if cdcs:
            break
    
    return cdcs


def resolve_wsdl(env: str, wsdl_arg: Optional[str]) -> str:
    """
    Resuelve la URL del WSDL para consulta_lote seg√∫n prioridad.
    
    Prioridad:
    1. wsdl_arg (si viene por CLI)
    2. SIFEN_WSDL_CONSULTA_LOTE (env var)
    3. Default seg√∫n ambiente
    
    Args:
        env: Ambiente ('test' o 'prod')
        wsdl_arg: URL WSDL desde CLI (opcional)
        
    Returns:
        URL del WSDL
    """
    # Prioridad 1: CLI argument
    if wsdl_arg:
        return wsdl_arg.strip()
    
    # Prioridad 2: Env var
    env_wsdl = os.getenv("SIFEN_WSDL_CONSULTA_LOTE")
    if env_wsdl:
        return env_wsdl.strip()
    
    # Prioridad 3: Default seg√∫n ambiente (con .wsdl)
    if env == "test":
        return "https://sifen-test.set.gov.py/de/ws/consultas/consulta-lote.wsdl?wsdl"
    else:
        return "https://sifen.set.gov.py/de/ws/consultas/consulta-lote.wsdl?wsdl"


class LoggingTransport(Transport):
    """
    Transport personalizado que imprime respuestas HTTP crudas antes de que zeep las parsee.
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
    
    def post(self, address, message, headers):
        """
        Sobrescribe el m√©todo post para imprimir la respuesta HTTP cruda.
        """
        try:
            # Obtener informaci√≥n de la sesi√≥n antes del POST
            session = self.session if hasattr(self, 'session') else None
            timeout = getattr(self, 'timeout', 'N/A')
            
            # Determinar env desde la URL
            env = 'test' if 'sifen-test' in address.lower() else ('prod' if 'sifen.set.gov.py' in address.lower() else 'unknown')
            
            # Verificar si se est√° usando certificado cliente
            has_cert = False
            if session and hasattr(session, 'cert'):
                cert = session.cert
                if cert:
                    has_cert = True
            
            # Verificar verify
            verify = getattr(session, 'verify', 'N/A') if session else 'N/A'
            
            # Imprimir informaci√≥n antes del POST
            print(f"[SIFEN DEBUG] PRE-POST: url={address} env={env} timeout={timeout} verify={verify} cert={'YES' if has_cert else 'NO'}")
            
            response = super().post(address, message, headers)
            
            # Imprimir respuesta HTTP cruda para diagn√≥stico
            if hasattr(response, 'status_code') and hasattr(response, 'headers') and hasattr(response, 'content'):
                status_code = response.status_code
                content_type = response.headers.get('Content-Type', 'N/A')
                content_length = response.headers.get('Content-Length', 'N/A')
                
                # Obtener preview del body (primeros 200 caracteres)
                try:
                    if response.content:
                        # Intentar decodificar como texto
                        try:
                            body_preview = response.text[:200]
                        except (UnicodeDecodeError, AttributeError):
                            # Si no se puede decodificar, mostrar como bytes
                            body_preview = str(response.content[:200])
                    else:
                        body_preview = "<EMPTY>"
                except Exception as e:
                    body_preview = f"<ERROR al leer body: {e}>"
                
                # URL final (puede ser diferente a address si hubo redirect)
                final_url = getattr(response, 'url', address)
                
                # Imprimir informaci√≥n despu√©s del POST
                print(f"[SIFEN DEBUG] POST-RESPONSE: url={final_url} status={status_code} "
                      f"ct={content_type} len={content_length} body_preview={body_preview}")
            
            return response
        except Exception as e:
            # Si falla, intentar obtener informaci√≥n de la respuesta si est√° disponible
            error_type = type(e).__name__
            error_msg = str(e)
            
            if hasattr(e, 'response') and e.response is not None:
                resp = e.response
                status_code = getattr(resp, 'status_code', 'N/A')
                content_type = resp.headers.get('Content-Type', 'N/A') if hasattr(resp, 'headers') else 'N/A'
                content_length = resp.headers.get('Content-Length', 'N/A') if hasattr(resp, 'headers') else 'N/A'
                
                try:
                    if resp.content:
                        try:
                            body_preview = resp.text[:200]
                        except (UnicodeDecodeError, AttributeError):
                            body_preview = str(resp.content[:200])
                    else:
                        body_preview = "<EMPTY>"
                except Exception:
                    body_preview = "<ERROR al leer body>"
                
                final_url = getattr(resp, 'url', address)
                
                print(f"[SIFEN DEBUG] POST-ERROR (con response): url={final_url} status={status_code} "
                      f"ct={content_type} len={content_length} body_preview={body_preview} "
                      f"error_type={error_type} error_msg={error_msg[:100]}")
            else:
                # Error sin response (ej: timeout, conexi√≥n)
                print(f"[SIFEN DEBUG] POST-ERROR (sin response): url={address} "
                      f"error_type={error_type} error_msg={error_msg[:200]}")
            
            raise


def _http_consulta_lote_manual(
    endpoint_url: str,
    prot: str,
    env: str,
    *,
    cert_tuple: Tuple[str, str],
    artifacts_dir: Path,
) -> str:
    """
    Hace un POST manual al endpoint SOAP real (NO al ?wsdl) para diagn√≥stico.
    
    Args:
        endpoint_url: URL del endpoint SOAP real (sin ?wsdl)
        prot: dProtConsLote (n√∫mero de lote)
        env: Ambiente ('test' o 'prod')
        cert_tuple: Tuple de certificados (cert_path, key_path)
        artifacts_dir: Directorio donde guardar los artifacts
        
    Returns:
        XML de respuesta como string
        
    Raises:
        RuntimeError: Si la respuesta no es XML v√°lido o est√° vac√≠a
    """
    import time
    import json
    from datetime import datetime

# Helper: asegurar bytes (evita write_bytes(_ensure_bytes(None)))
def _ensure_bytes(x):
    if x is None:
        return b""
    if isinstance(x, (bytes, bytearray)):
        return bytes(x)
    if isinstance(x, str):
        return x.encode("utf-8", "ignore")
    return str(x).encode("utf-8", "ignore")


# dId requerido por SIFEN (15 d√≠gitos tipo YYYYMMDDHHMMSSmmm)
def _make_did() -> str:
    return datetime.now().strftime('%Y%m%d%H%M%S%f')[:15]

    from requests.exceptions import ConnectionError, HTTPError
    
    # Crear sesi√≥n con mTLS (sin Connection: close para mantener Keep-Alive)
    session = Session()
    session.cert = cert_tuple
    session.verify = True
    # NO setear "Connection: close" - dejar Keep-Alive
    
    # SOAP 1.2 seg√∫n XSD WS_SiConsLote_v141.xsd
    # Namespace seg√∫n Manual T√©cnico SIFEN v141
    sifen_ns = "http://ekuatia.set.gov.py/sifen/xsd"
    
    did = _make_did()

    
    soap_body = f'''<?xml version="1.0" encoding="UTF-8"?>
<soap12:Envelope xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
    <soap12:Body>
        <rEnviConsLoteDe xmlns="{sifen_ns}">
            <dId>{did}</dId>
            <dProtConsLote>{prot}</dProtConsLote>
        </rEnviConsLoteDe>
    </soap12:Body>
</soap12:Envelope>'''
    
    # Headers para SOAP 1.2
    headers = {
        "Content-Type": f'application/soap+xml; charset=utf-8; action="{SIFEN_CONS_LOTE_ACTION}"',
        "Accept": "application/soap+xml, text/xml, */*",
        "Connection": "close",
    }
    
    timeout = (10, 60)  # (connect, read)
    
    # Guardar request antes de enviar
    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    req_path = artifacts_dir / f"consulta_lote_sent_{ts}.xml"
    resp_path = artifacts_dir / f"consulta_lote_response_{ts}.xml"
    meta_path = artifacts_dir / f"consulta_lote_headers_sent_{ts}.json"
    
    try:
        req_path.write_bytes(_ensure_bytes(soap_body.encode('utf-8')))
        meta_path.write_text(
            json.dumps(
                {
                    "timestamp": datetime.now().isoformat(),
                    "env": env,
                    "endpoint": endpoint_url,
                    "timeout": timeout,
                    "sent_headers": headers,
                    "dId": int(did),
                    "dProtConsLote": prot,
                },
                ensure_ascii=False,
                indent=2,
            ),
            encoding="utf-8",
        )
    except Exception as e:
        pass  # Error saving artifacts, continue with request
    
    # Intentar endpoints: primary (con .wsdl) y fallback (sin .wsdl)
    endpoints_to_try = [endpoint_url]
    
    # Si el endpoint termina en .wsdl, agregar tambi√©n la versi√≥n sin .wsdl como fallback
    if endpoint_url.endswith(".wsdl"):
        fallback_url = endpoint_url[:-5]  # Quitar ".wsdl"
        endpoints_to_try.append(fallback_url)
    
    # Para cada endpoint, hacer hasta 3 intentos con backoff
    for endpoint_idx, endpoint in enumerate(endpoints_to_try):
        endpoint_name = f"endpoint {'A' if endpoint_idx == 0 else 'B'}"
        print(f"[SIFEN HTTP] Intentando {endpoint_name}: {endpoint}")
        print(f"[SIFEN HTTP] cert={'YES' if session.cert else 'NO'} verify={session.verify} timeout={timeout}")
        
        for attempt in range(1, 4):  # 3 intentos
            if attempt > 1:
                sleep_time = attempt - 1  # 1s, 2s, 3s (attempt 2->1s, attempt 3->2s)
                print(f"[SIFEN HTTP] Reintento {attempt}/3 para {endpoint_name} (esperando {sleep_time}s)...")
                time.sleep(sleep_time)
            
            try:
                # Hacer POST manual
                response = session.post(
                    endpoint,
                    data=soap_body.encode('utf-8'),
                    headers=headers,
                    timeout=timeout
                )
                
                # Loguear respuesta
                status_code = response.status_code
                content_type = response.headers.get('Content-Type', 'N/A')
                content_length = response.headers.get('Content-Length', 'N/A')
                
                # Obtener preview del body
                try:
                    if response.content:
                        try:
                            body_preview = response.text[:300]
                        except (UnicodeDecodeError, AttributeError):
                            body_preview = str(response.content[:300])
                    else:
                        body_preview = "<EMPTY>"
                except Exception as e:
                    body_preview = f"<ERROR al leer body: {e}>"
                
                print(f"[SIFEN HTTP] status={status_code} ct={content_type} len={content_length} body_preview={body_preview}")
                
                # Validar que la respuesta es XML v√°lido
                if not response.content:
                    raise RuntimeError(f"Respuesta vac√≠a del servidor (status={status_code})")
                
                # Intentar parsear como XML para validar
                try:
                    import xml.etree.ElementTree as ET
                    ET.fromstring(response.content)
                except ET.ParseError as e:
                    raise RuntimeError(f"Respuesta no es XML v√°lido (status={status_code}): {str(e)[:200]}")
                
                # Retornar respuesta como texto
                print(f"[SIFEN HTTP] ‚úÖ √âxito con {endpoint_name} (intento {attempt})")
                
                # Guardar response
                try:
                    resp_path.write_bytes(_ensure_bytes(response.content or b""))
                    # Actualizar meta con status y headers si existe
                    try:
                        meta = json.loads(meta_path.read_text(encoding="utf-8"))
                        meta.update(
                            {
                                "http_status": status_code,
                                "received_headers": dict(response.headers),
                            }
                        )
                        meta_path.write_text(json.dumps(meta, ensure_ascii=False, indent=2), encoding="utf-8")
                    except FileNotFoundError:
                        pass  # Meta file not found, response still saved
                except Exception as e:
                    pass  # Error saving response metadata
                
                return response.text
                
            except (ConnectionError, HTTPError) as e:
                error_msg = str(e)
                print(f"[SIFEN HTTP] ‚ùå Intento {attempt}/3 para {endpoint_name} fall√≥: {type(e).__name__}: {error_msg[:100]}")
                
                # Si es RemoteDisconnected y no es el √∫ltimo intento, continuar con retries
                if "RemoteDisconnected" in error_msg or "ConnectionError" in error_msg:
                    if attempt < 3:
                        continue  # Reintentar
                    else:
                        # √öltimo intento fall√≥, probar siguiente endpoint si hay
                        break
                else:
                    # Otro tipo de error, no reintentar
                    raise
            except Exception as e:
                print(f"[SIFEN HTTP] EXC {type(e).__name__}: {str(e)[:200]}")
                if attempt < 3:
                    continue
                else:
                    raise
    
    # Si llegamos aqu√≠, todos los intentos fallaron
    raise RuntimeError(f"Todos los intentos de conexi√≥n fallaron. Endpoints probados: {', '.join(endpoints_to_try)}")


def _resolve_mtls(cert_path: Optional[str] = None, key_or_password: Optional[str] = None, is_pem_mode: Optional[bool] = None):
    """Centraliza resoluci√≥n de certificados para PEM o P12.

    Si se pasan valores expl√≠citos (como resultado de get_mtls_config) los usa,
    en caso contrario invoca get_mtls_config() internamente.
    Devuelve tuple (cert_tuple, temp_files, resolved_mode) donde:
      - cert_tuple: (cert, key) listo para session.cert
      - temp_files: (cert, key) temporales si se generaron (para cleanup)
      - resolved_mode: 'PEM' o 'P12'
    """

    if cert_path is None or key_or_password is None or is_pem_mode is None:
        cert_path, key_or_password, is_pem_mode = get_mtls_config()

    temp_files: Optional[Tuple[str, str]] = None

    if is_pem_mode:
        cert_tuple = (cert_path, key_or_password)
        return cert_tuple, temp_files, "PEM"

    cert_pem_path, key_pem_path = p12_to_temp_pem_files(cert_path, str(key_or_password))
    temp_files = (cert_pem_path, key_pem_path)
    return (cert_pem_path, key_pem_path), temp_files, "P12"


def create_zeep_transport(cert_path: str, cert_password: Optional[str], *, is_pem_mode: bool = False) -> Transport:
    """
    Crea un Transport de zeep con mTLS configurado.
    
    Args:
        cert_path: Ruta al certificado P12
        cert_password: Contrase√±a del certificado
        
    Returns:
        Transport configurado con mTLS
    """
    session = Session()
    
    try:
        cert_tuple, temp_files, mode = _resolve_mtls(
            cert_path=cert_path,
            key_or_password=cert_password,
            is_pem_mode=is_pem_mode,
        )
        if temp_files:
            cert_pem_path, key_pem_path = temp_files
            import os
            print(
                f"[SIFEN DEBUG] create_zeep_transport: cert_pem={os.path.basename(cert_pem_path)} exists={os.path.exists(cert_pem_path)}"
            )
            print(
                f"[SIFEN DEBUG] create_zeep_transport: key_pem={os.path.basename(key_pem_path)} exists={os.path.exists(key_pem_path)}"
            )
        session.cert = cert_tuple
    except PKCS12Error as e:
        raise SifenClientError(f"Error al convertir certificado P12 a PEM: {e}") from e
    
    session.verify = True
    
    # Configurar HTTPAdapter con retries para manejar ConnectionResetError
    if URLLIB3_RETRY_AVAILABLE:
        retry = Retry(
            total=3,
            connect=3,
            read=3,
            backoff_factor=0.5,
            status_forcelist=[502, 503, 504],
            allowed_methods=frozenset(["GET", "POST"]),
            raise_on_status=False
        )
        adapter = HTTPAdapter(max_retries=retry, pool_connections=10, pool_maxsize=10)
    else:
        adapter = HTTPAdapter(pool_connections=10, pool_maxsize=10)
    
    session.mount("https://", adapter)
    # NO setear "Connection: close" - dejar Keep-Alive para reutilizar conexiones y cookies
    
    timeout = (10, 30)
    
    # Debug: verificar configuraci√≥n de la sesi√≥n
    print(f"[SIFEN NET] transport session cookies enabled; cert={'YES' if session.cert else 'NO'} verify={session.verify}")
    
    # Crear cache para WSDL/XSD
    cache = InMemoryCache()
    
    return LoggingTransport(
        session=session,
        timeout=timeout,  # connect 10s, read 30s
        operation_timeout=30,
        cache=cache,
    )


def call_consulta_lote_raw(
    session: Any,
    env: str,
    prot: str,
    timeout: int = 30,
    did: Optional[str] = None,
    artifacts_dir: Optional[Path] = None,
) -> str:
    """
    Consulta el estado de un lote usando request directo estilo "try08" (sin Zeep).
    
    Esta funci√≥n es usada por lote_checker.py y otros m√≥dulos internos.
    
    Args:
        session: requests.Session con mTLS configurado (puede ser None, se crear√° uno nuevo)
        env: Ambiente ('test' o 'prod')
        prot: dProtConsLote (n√∫mero de lote)
        timeout: Timeout en segundos
        
    Returns:
        XML de respuesta como string
    """
    import datetime as _dt
    import os
    import random
    import requests
    from app.sifen_client.config import get_mtls_config, get_sifen_config
    from app.sifen_client.pkcs12_utils import p12_to_temp_pem_files
    
    # Validaci√≥n m√≠nima (dProtConsLote debe ser num√©rico)
    prot = str(prot or "").strip()
    if not prot.isdigit():
        raise ValueError(f"dProtConsLote debe ser solo d√≠gitos. Valor recibido: '{prot}'")

    # dId recomendado: 15 d√≠gitos (YYYYMMDDHHMMSS + 1 d√≠gito random)
    did = str(did or "").strip()
    if not re.fullmatch(r"\d{15}", did):
        base = _dt.datetime.now().strftime("%Y%m%d%H%M%S")  # 14 d√≠gitos
        did = base + str(random.randint(0, 9))

    # Resolver artifacts_dir (si no se pasa, usar tesaka-cv/artifacts)
    if artifacts_dir is None:
        artifacts_dir = Path(__file__).resolve().parents[1] / "artifacts"
    artifacts_dir.mkdir(parents=True, exist_ok=True)

    # Obtener configuraci√≥n y certificado mTLS
    config = get_sifen_config(env=env)
    cert_path, key_or_password, is_pem_mode = get_mtls_config()
    if not cert_path:
        cert_path = config.cert_path
    if not key_or_password and not is_pem_mode:
        key_or_password = config.cert_password
    if not cert_path or (not is_pem_mode and not key_or_password):
        raise SifenClientError("Falta certificado mTLS para consulta lote (PEM o P12)")
    
    # Usar el helper unificado para resolver certificados
    cert_tuple, temp_files, mode = _resolve_mtls(cert_path, key_or_password, is_pem_mode)
    
    if mode == "P12":
        cert_pem_path, key_pem_path = temp_files
        print(
            f"[SIFEN DEBUG] call_consulta_lote_raw: cert_pem={os.path.basename(cert_pem_path)} "
            f"key_pem={os.path.basename(key_pem_path)}"
        )
    
    try:
        # Endpoint (con .wsdl seg√∫n config)
        if env == "prod":
            endpoint = "https://sifen.set.gov.py/de/ws/consultas/consulta-lote"
        else:
            endpoint = "https://sifen-test.set.gov.py/de/ws/consultas/consulta-lote"
        
        print(f"[SIFEN DEBUG] call_consulta_lote_raw: endpoint={endpoint} env={env} prot={prot}")
        
        # SOAP 1.2 (WSDL-driven): Body contiene rEnviConsLoteDe DIRECTO (sin wrapper)
        # WSDL local observado: operaci√≥n rEnviConsLoteDe, soapAction="" (vac√≠o)
        soap = f"""<?xml version='1.0' encoding='utf-8'?>
<soap-env:Envelope xmlns:soap-env="http://www.w3.org/2003/05/soap-envelope">
  <soap-env:Body>
    <ns0:rEnviConsLoteDe xmlns:ns0="http://ekuatia.set.gov.py/sifen/xsd">
      <ns0:dId>{did}</ns0:dId>
      <ns0:dProtConsLote>{prot}</ns0:dProtConsLote>
    </ns0:rEnviConsLoteDe>
  </soap-env:Body>
</soap-env:Envelope>
""".encode("utf-8")
        
        headers = {
            # SOAP 1.2: NO usar header SOAPAction separado; action va en Content-Type
            "Content-Type": f'application/soap+xml; charset=utf-8; action="{SIFEN_CONS_LOTE_ACTION}"',
            "Accept": "application/soap+xml",
        }

        # Guardar request/headers SIEMPRE en artifacts (nombres √∫nicos)
        ts = _dt.datetime.now().strftime("%Y%m%d_%H%M%S")
        req_path = artifacts_dir / f"consulta_lote_sent_{ts}.xml"
        resp_path = artifacts_dir / f"consulta_lote_response_{ts}.xml"
        meta_path = artifacts_dir / f"consulta_lote_headers_sent_{ts}.json"
        try:
            req_path.write_bytes(_ensure_bytes(soap))
            meta_path.write_text(
                json.dumps(
                    {
                        "timestamp": datetime.now().isoformat(),
                        "env": env,
                        "endpoint": endpoint,
                        "timeout": timeout,
                        "sent_headers": headers,
                        "dId": did,
                        "dProtConsLote": prot,
                    },
                    ensure_ascii=False,
                    indent=2,
                ),
                encoding="utf-8",
            )
        except Exception as e:
            print(f"[SIFEN DEBUG] call_consulta_lote_raw: no se pudo guardar request/meta: {e}")
        
        # Usar session existente si est√° disponible, o crear una nueva
        if session and hasattr(session, 'cert') and session.cert:
            # Reutilizar session existente con mTLS ya configurado
            print(f"[SIFEN DEBUG] call_consulta_lote_raw: reutilizando session existente con cert")
        else:
            # Crear nueva session con mTLS
            session = requests.Session()
            session.verify = True
            session.cert = cert_tuple
            if cert_tuple:
                print(
                    f"[SIFEN DEBUG] call_consulta_lote_raw: nueva session con cert={os.path.basename(cert_tuple[0])} "
                    f"key={os.path.basename(cert_tuple[1])}"
                )
        
        r = session.post(endpoint, data=soap, headers=headers, timeout=timeout)
        
        resp_status = r.status_code
        ct = r.headers.get('Content-Type', 'N/A')
        cl = r.headers.get('Content-Length', 'N/A')
        text = r.text or ""
        body_preview = text[:300] if text else "<EMPTY>"
        
        print(f"[SIFEN HTTP] status={resp_status} ct={ct} len={cl} body_preview={body_preview}")

        # Guardar response SIEMPRE en artifacts (aunque HTTP != 200)
        try:
            resp_path.write_bytes(_ensure_bytes(r.content or b""))
            # ALSO: guardar raw response con el nombre que el analizador espera
            try:
                raw_path = Path(str(meta_path).replace(".json","") + ".raw_response.xml")
                raw_path.write_bytes(_ensure_bytes(r.content or b""))
            except Exception:
                pass

            # Actualizar meta con status y headers de respuesta
            meta = json.loads(meta_path.read_text(encoding="utf-8"))
            meta.update(
                {
                    "http_status": resp_status,
                    "received_headers": dict(r.headers),
                }
            )
            meta_path.write_text(json.dumps(meta, ensure_ascii=False, indent=2), encoding="utf-8")
        except Exception as e:
            print(f"[SIFEN DEBUG] call_consulta_lote_raw: no se pudo guardar response/meta: {e}")
        
        # IMPORTANTE: aunque venga 400, si el body es XML lo devolvemos igual
        if text.lstrip().startswith("<"):
            return text
        
        raise RuntimeError(f"Consulta lote sin XML. HTTP={resp_status} ct={ct} body_preview={body_preview}")
        
    finally:
        # Limpiar archivos PEM temporales solo si no es modo PEM
        if mode == "P12" and temp_files:
            cleanup_pem_files(temp_files[0], temp_files[1])


def consulta_ruc_cli(args: argparse.Namespace) -> int:
    """Subcomando CLI para consultar RUC."""
    from app.sifen_client.soap_client import SoapClient
    
    # Forzar ambiente desde args (anti-regresi√≥n 0160)
    force_env_from_args(args.env)
    
    env = args.env
    ruc = args.ruc
    dump_http = args.dump_http
    debug = args.debug
    
    print(f"üîç Consultando RUC: {ruc} (ambiente: {env})")
    print()
    
    # Resolver password P12
    p12_password = resolve_p12_password(args)
    
    # Obtener configuraci√≥n
    config = get_sifen_config(env=env)
    _apply_mtls_to_cli_config(config)
    
    # Crear cliente SOAP
    try:
        with SoapClient(config) as client:
            result = client.consulta_ruc_raw(ruc=ruc, dump_http=dump_http)
            
            http_status = result.get("http_status", 0)
            raw_xml = result.get("raw_xml", "")
            d_cod_res = result.get("dCodRes", "N/A")
            d_msg_res = result.get("dMsgRes", "N/A")
            x_cont_ruc = result.get("xContRUC", {})
            
            print("="*70)
            print("RESULTADO DE CONSULTA RUC")
            print("="*70)
            print(f"HTTP Status: {http_status}")
            print(f"C√≥digo: {d_cod_res}")
            print(f"Mensaje: {d_msg_res}")
            print()
            
            if x_cont_ruc:
                print("üìã Informaci√≥n del Contribuyente:")
                print(f"   RUC: {x_cont_ruc.get('dRUCCons', 'N/A')}")
                print(f"   Raz√≥n Social: {x_cont_ruc.get('dRazCons', 'N/A')}")
                print(f"   C√≥digo Estado: {x_cont_ruc.get('dCodEstCons', 'N/A')}")
                print(f"   Descripci√≥n Estado: {x_cont_ruc.get('dDesEstCons', 'N/A')}")
                
                ruc_fact_elec = x_cont_ruc.get('dRUCFactElec', 'N/A')
                if ruc_fact_elec == "1":
                    print(f"   ‚úÖ Habilitado para Facturaci√≥n Electr√≥nica: S√ç")
                elif ruc_fact_elec == "0":
                    print(f"   ‚ùå Habilitado para Facturaci√≥n Electr√≥nica: NO")
                else:
                    print(f"   ‚ö†Ô∏è  Habilitado para Facturaci√≥n Electr√≥nica: {ruc_fact_elec}")
                print()
            
            # Interpretar c√≥digos
            if d_cod_res == "0502":
                print("‚úÖ RUC encontrado y v√°lido")
            elif d_cod_res == "0500":
                print("‚ùå RUC inexistente")
            elif d_cod_res == "0501":
                print("‚ùå Sin permiso para consultar este RUC")
            else:
                print(f"‚ö†Ô∏è  C√≥digo desconocido: {d_cod_res}")
            
            # Guardar artifacts si debug est√° activo
            if debug:
                artifacts_dir = Path(__file__).parent.parent / "artifacts"
                artifacts_dir.mkdir(exist_ok=True)
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                
                # Guardar respuesta XML
                if raw_xml:
                    resp_file = artifacts_dir / f"consulta_ruc_response_{timestamp}.xml"
                    resp_file.write_text(raw_xml, encoding="utf-8")
                    print(f"\nüíæ Respuesta XML guardada: {resp_file.name}")
                
                # Guardar resultado JSON
                result_json = {
                    "ruc": ruc,
                    "env": env,
                    "timestamp": timestamp,
                    "http_status": http_status,
                    "dCodRes": d_cod_res,
                    "dMsgRes": d_msg_res,
                    "xContRUC": x_cont_ruc,
                }
                json_file = artifacts_dir / f"consulta_ruc_{timestamp}.json"
                json_file.write_text(
                    json.dumps(result_json, ensure_ascii=False, indent=2, default=str),
                    encoding="utf-8"
                )
                print(f"üíæ Resultado JSON guardado: {json_file.name}")
            
            return 0
            
    except Exception as e:
        print(f"‚ùå Error al consultar RUC: {e}", file=sys.stderr)
        if debug:
            import traceback
            traceback.print_exc()
        return 1

def _parse_consulta_lote_response(response_xml):
    """
    Parser robusto para respuestas SOAP de consulta-lote.
    Devuelve dict normalizado con:
      - fallback_shape (rRetEnviDe | rResEnviConsLoteDe | rEnviConsLoteDeResponse | unknown)
      - dFecProc, dCodResLot, dMsgResLot cuando sea posible
      - raw_xml siempre
    """
    from lxml import etree

    if isinstance(response_xml, bytes):
        raw = response_xml
        raw_str = response_xml.decode("utf-8", errors="replace")
    else:
        raw_str = str(response_xml)
        raw = raw_str.encode("utf-8")

    def _first_text(root, xpath_expr: str):
        vals = root.xpath(xpath_expr)
        if not vals:
            return None
        v = vals[0]
        if isinstance(v, (bytes, str)):
            s = v.decode("utf-8", "replace") if isinstance(v, bytes) else v
        else:
            s = str(v)
        s = (s or "").strip()
        return s or None

    try:
        root = etree.fromstring(raw)
    except Exception as e:
        return {"raw_xml": raw_str, "parse_error": f"XML inv√°lido: {e}", "fallback_shape": "unknown"}

    # Caso C: rResEnviConsLoteDe (lo viste en TEST con 0362)
    if root.xpath('//*[local-name()="rResEnviConsLoteDe"]'):
        dFecProc   = _first_text(root, '//*[local-name()="dFecProc"]/text()')
        dCodResLot = _first_text(root, '//*[local-name()="dCodResLot"]/text()')
        dMsgResLot = _first_text(root, '//*[local-name()="dMsgResLot"]/text()')
        return {
            "raw_xml": raw_str,
            "fallback_shape": "rResEnviConsLoteDe",
            "dFecProc": dFecProc,
            "dCodResLot": dCodResLot,
            "dMsgResLot": dMsgResLot,
        }

    # Caso B: rRetEnviDe (errores como 0160 vienen as√≠)
    if root.xpath('//*[local-name()="rRetEnviDe"]'):
        dFecProc = _first_text(root, '//*[local-name()="dFecProc"]/text()')
        dCodRes  = _first_text(root, '//*[local-name()="dCodRes"]/text()')
        dMsgRes  = _first_text(root, '//*[local-name()="dMsgRes"]/text()')
        return {
            "raw_xml": raw_str,
            "fallback_shape": "rRetEnviDe",
            "dFecProc": dFecProc,
            "dCodResLot": dCodRes,
            "dMsgResLot": dMsgRes,
        }

    # Caso A: rEnviConsLoteDeResponse (shape ‚Äúideal‚Äù del WSDL)
    if root.xpath('//*[local-name()="rEnviConsLoteDeResponse"]'):
        dFecProc   = _first_text(root, '//*[local-name()="dFecProc"]/text()')
        dCodResLot = _first_text(root, '//*[local-name()="dCodResLot"]/text()')
        dMsgResLot = _first_text(root, '//*[local-name()="dMsgResLot"]/text()')
        # fallback: a veces est√°n como dCodRes/dMsgRes
        if not dCodResLot:
            dCodResLot = _first_text(root, '//*[local-name()="dCodRes"]/text()')
        if not dMsgResLot:
            dMsgResLot = _first_text(root, '//*[local-name()="dMsgRes"]/text()')
        return {
            "raw_xml": raw_str,
            "fallback_shape": "rEnviConsLoteDeResponse",
            "dFecProc": dFecProc,
            "dCodResLot": dCodResLot,
            "dMsgResLot": dMsgResLot,
        }

    return {"raw_xml": raw_str, "parse_error": "Shape desconocido", "fallback_shape": "unknown"}




def main() -> int:
    """Funci√≥n principal del script."""
    parser = argparse.ArgumentParser(
        description="Consultar estado de lote SIFEN (dProtConsLote).",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "--env",
        choices=["test", "prod"],
        default="test",
        help="Ambiente SIFEN (default: test)",
    )
    parser.add_argument(
        "--prot",
        required=False,
        help="dProtConsLote devuelto por siRecepLoteDE (requerido si no se usa --ruc)",
    )
    parser.add_argument(
        "--out",
        default="",
        help="Guardar respuesta en JSON (ruta). Si no se especifica, se guarda en artifacts/",
    )
    parser.add_argument(
        "--debug",
        action="store_true",
        help="Logs extra de debug",
    )
    parser.add_argument(
        "--wsdl",
        default=None,
        help="Override WSDL URL (opcional). Ej: https://sifen-test.set.gov.py/de/ws/async/recibe-lote.wsdl?wsdl",
    )
    parser.add_argument(
        "--wsdl-file",
        default=None,
        type=str,
        help="Usar archivo WSDL local (no descargar desde internet). Ej: artifacts/consulta-lote.wsdl.xml",
    )
    parser.add_argument(
        "--wsdl-cache-dir",
        default="artifacts",
        type=str,
        help="Directorio para cache de WSDL/XSD (default: artifacts)",
    )
    parser.add_argument(
        "--artifacts-dir",
        default=None,
        type=str,
        help="Directorio para guardar artifacts (default: same as --wsdl-cache-dir)",
    )
    parser.add_argument(
        "--p12-password",
        default=None,
        type=str,
        help="Contrase√±a del certificado P12 (opcional, para debug interactivo). "
             "Por defecto se busca en env vars o se pide interactivamente.",
    )
    parser.add_argument(
        "--dump-http",
        action="store_true",
        help="Mostrar evidencia completa del HTTP request/response (headers, SOAP envelope, body). "
             "Incluye validaciones autom√°ticas de SOAP 1.2.",
    )
    parser.add_argument(
        "--ruc",
        type=str,
        help="Consultar RUC en lugar de lote. Proporciona el RUC (puede incluir DV como 'RUC-DV', ej: --ruc 4554737-8 o --ruc 80012345)",
    )
    args = parser.parse_args()
    
    # Si se proporciona --ruc, ejecutar consulta de RUC
    if args.ruc:
        return consulta_ruc_cli(args)
    
    # Validar que --prot est√© presente si no se usa --ruc
    if not args.prot:
        _die("Se requiere --prot (dProtConsLote) o --ruc para consultar.")
    
    # despu√©s de: args = ap.parse_args()
    debug_enabled = bool(getattr(args, "debug", False)) or os.getenv("SIFEN_DEBUG_SOAP", "").strip() in ("1", "true", "TRUE", "yes", "YES")
    
    # Validar prot
    prot = str(args.prot).strip()
    if not prot or not prot.isdigit():
        _die("dProtConsLote debe ser un n√∫mero (solo d√≠gitos).")
    
    # Obtener certificado desde env
    try:
        cert_path, key_or_password, is_pem_mode = get_mtls_config()
    except RuntimeError as e:
        _die(str(e))
    
    # Preparar cache_dir para WSDL/XSD
    cache_dir = Path(args.wsdl_cache_dir)
    if not cache_dir.is_absolute():
        cache_dir = Path(__file__).parent.parent / cache_dir
    cache_dir.mkdir(parents=True, exist_ok=True)
    
    # Preparar artifacts_dir para guardar archivos de respuesta
    # Si no se especifica, usar el mismo que cache_dir
    artifacts_dir = Path(args.artifacts_dir) if args.artifacts_dir else cache_dir
    if not artifacts_dir.is_absolute():
        artifacts_dir = Path(__file__).parent.parent / artifacts_dir
    artifacts_dir.mkdir(exist_ok=True)
    
    # Si --dump-http est√° activo, usar consulta_lote_raw() directamente (sin zeep)
    if args.dump_http:
        try:
            from app.sifen_client.soap_client import SoapClient
            from app.sifen_client.config import get_sifen_config
            
            config = get_sifen_config(env=args.env)
            client = SoapClient(config)
            
            print("\n" + "="*70)
            print("VERIFICADOR E2E: rEnviConsLoteDe (SOAP 1.2, sin wrapper)")
            print("="*70)
            
            # Llamar consulta_lote_raw con dump_http=True
            result = client.consulta_lote_raw(prot, did=1, dump_http=True)
            
            # 1. Headers HTTP enviados
            print("\n1Ô∏è‚É£  HEADERS HTTP ENVIADOS:")
            print("-" * 70)
            sent_headers = result.get("sent_headers", {})
            for key, value in sorted(sent_headers.items()):
                print(f"   {key}: {value}")
            
            # Validaci√≥n: Content-Type debe ser application/soap+xml
            content_type = sent_headers.get("Content-Type", "")
            if "application/soap+xml" not in content_type:
                print(f"\n‚ùå VALIDACI√ìN FALLIDA: Content-Type debe contener 'application/soap+xml'")
                print(f"   Encontrado: {content_type}")
                cleanup_pem_files()
                sys.exit(1)
            else:
                print(f"\n   ‚úÖ Content-Type correcto: {content_type}")
            
            # Validaci√≥n: NO debe haber SOAPAction header separado
            if "SOAPAction" in sent_headers:
                print(f"\n‚ùå VALIDACI√ìN FALLIDA: NO debe existir header 'SOAPAction' en SOAP 1.2")
                print(f"   Encontrado: SOAPAction = {sent_headers['SOAPAction']}")
                cleanup_pem_files()
                sys.exit(1)
            else:
                print(f"   ‚úÖ NO hay header 'SOAPAction' (correcto para SOAP 1.2)")
            
            # Validaci√≥n opcional: si action= est√° presente en Content-Type, es recomendado
            if 'action="rEnviConsLoteDe"' in content_type:
                print(f"   ‚úÖ Recomendado: Content-Type incluye action=\"rEnviConsLoteDe\" (ayuda al enrutamiento)")
            elif 'action=' in content_type:
                print(f"   ‚ÑπÔ∏è  Content-Type incluye action= (permitido en SOAP 1.2)")
            
            # 2. SOAP Envelope enviado
            print("\n2Ô∏è‚É£  SOAP ENVELOPE ENVIADO:")
            print("-" * 70)
            sent_xml = result.get("sent_xml", "")
            if sent_xml:
                xml_lines = sent_xml.split("\n")
                if len(xml_lines) > 80:
                    print("\n".join(xml_lines[:80]))
                    print(f"\n... (truncado, total {len(xml_lines)} l√≠neas)")
                else:
                    print(sent_xml)
                
                # Validaciones del XML
                print("\n   Validaciones del XML:")
                # Validar namespace SOAP 1.2
                if "http://www.w3.org/2003/05/soap-envelope" not in sent_xml:
                    print(f"   ‚ùå VALIDACI√ìN FALLIDA: Envelope debe usar namespace SOAP 1.2")
                    print(f"      Esperado: http://www.w3.org/2003/05/soap-envelope")
                    cleanup_pem_files()
                    sys.exit(1)
                else:
                    print(f"   ‚úÖ Namespace SOAP 1.2 correcto")
                
                # Validar rEnviConsLoteDe directamente en Body (sin wrapper)
                if "<sifen:rEnviConsLoteDe" not in sent_xml and "<rEnviConsLoteDe" not in sent_xml:
                    print(f"   ‚ùå VALIDACI√ìN FALLIDA: Debe existir 'rEnviConsLoteDe' en el Body")
                    cleanup_pem_files()
                    sys.exit(1)
                else:
                    print(f"   ‚úÖ 'rEnviConsLoteDe' encontrado en Body")
                
                # Validar que NO hay wrapper (rEnviConsLoteDe debe estar directamente en Body)
                if "<sifen:siResultLoteDE" in sent_xml or "<siResultLoteDE" in sent_xml:
                    print(f"   ‚ö†Ô∏è  ADVERTENCIA: Se encontr√≥ wrapper 'siResultLoteDE' (no deber√≠a estar presente)")
                else:
                    print(f"   ‚úÖ NO hay wrapper (rEnviConsLoteDe est√° directamente en Body)")
            else:
                print("   ‚ö†Ô∏è  No se pudo obtener XML enviado")
            
            # 3. Status code HTTP y headers recibidos
            print("\n3Ô∏è‚É£  STATUS CODE HTTP Y HEADERS RECIBIDOS:")
            print("-" * 70)
            http_status = result.get("http_status", 0)
            print(f"   Status Code: {http_status}")
            
            received_headers = result.get("received_headers", {})
            if received_headers:
                print("\n   Headers recibidos:")
                for key, value in sorted(received_headers.items()):
                    print(f"      {key}: {value}")
            else:
                print("   ‚ö†Ô∏è  No se pudieron obtener headers recibidos")
            
            # 4. Body recibido
            print("\n4Ô∏è‚É£  BODY RECIBIDO:")
            print("-" * 70)
            received_body = result.get("received_body_preview", "")
            if received_body:
                body_lines = received_body.split("\n")
                if len(body_lines) > 120:
                    print("\n".join(body_lines[:120]))
                    print(f"\n... (truncado, total {len(body_lines)} l√≠neas)")
                else:
                    print(received_body)
                
                # Detectar SOAP Fault
                if "<soap:Fault" in received_body or "<soap12:Fault" in received_body or "<Fault" in received_body:
                    print("\n   ‚ö†Ô∏è  SOAP FAULT DETECTADO en la respuesta")
                    # Intentar extraer c√≥digo y mensaje del fault
                    try:
                        from lxml import etree
                        fault_root = etree.fromstring(result.get("raw_xml", "").encode("utf-8"))
                        fault_code = fault_root.find(".//{http://www.w3.org/2003/05/soap-envelope}Code")
                        fault_reason = fault_root.find(".//{http://www.w3.org/2003/05/soap-envelope}Reason")
                        if fault_code is not None:
                            print(f"      Fault Code: {etree.tostring(fault_code, encoding='unicode')}")
                        if fault_reason is not None:
                            print(f"      Fault Reason: {etree.tostring(fault_reason, encoding='unicode')}")
                    except Exception:
                        pass
                else:
                    print("\n   ‚úÖ No se detect√≥ SOAP Fault")
            else:
                print("   ‚ö†Ô∏è  No se pudo obtener body recibido")
            
            print("\n" + "="*70)
            print("‚úÖ VERIFICACI√ìN COMPLETA")
            print("="*70 + "\n")
            
            cleanup_pem_files()
            return 0
            
        except SystemExit:
            raise
        except Exception as e:
            cleanup_pem_files()
            _die(f"Error en verificador E2E: {e}")
    
    # Resolver WSDL seg√∫n prioridad
    wsdl_url = resolve_wsdl(args.env, args.wsdl)
    
    # Resolver archivo WSDL (prove√≠do, cache, o descarga)
    wsdl_file_arg = Path(args.wsdl_file) if args.wsdl_file else None
    
    # Mostrar informaci√≥n
    print(f"üîß Ambiente: {args.env}")
    print(f"üåê WSDL URL: {wsdl_url}")
    if wsdl_file_arg:
        print(f"üìÇ WSDL File: {wsdl_file_arg}")
    print(f"üíæ Cache Dir: {cache_dir}")
    print(f"üîé dProtConsLote: {prot}")
    if args.debug:
        print(f"üîê Cert: {cert_path}")
    
    # Cargar WSDL (desde archivo, cache, o descarga) y crear cliente con fallback
    result_dict = None
    fallback_used = False
    history = None  # Declarar aqu√≠ para que sea accesible despu√©s
    
    try:
        # Intentar cargar WSDL y usar Zeep
        wsdl_path = load_wsdl_source(
            wsdl_url=wsdl_url,
            cache_dir=cache_dir,
            wsdl_file=wsdl_file_arg,
            cert_path=cert_path,
            key_or_password=key_or_password,
            is_pem_mode=is_pem_mode,
            debug=debug_enabled
        )
        if debug_enabled:
            print(f"‚úÖ WSDL cargado: {wsdl_path}")
        
        # Crear transporte con mTLS
        try:
            transport = create_zeep_transport(cert_path, key_or_password, is_pem_mode=is_pem_mode)
        except Exception as e:
            cleanup_pem_files()
            _die(f"Error al crear transporte mTLS: {e}")
        
        # Crear cliente zeep con history plugin (siempre, para debug en errores)
        history = HistoryPlugin()
        settings = Settings(strict=False, xml_huge_tree=True)
        
        try:
            client = Client(
                wsdl=str(wsdl_path),
                transport=transport,
                settings=settings,
                plugins=[history]
            )
        except Exception as e:
            raise Exception(f"Error al cargar WSDL desde archivo: {e}")
        
        # Listar servicios/puertos/operaciones en modo debug
        if debug_enabled:
            print("\nüìã Servicios disponibles en WSDL:")
            for svc_name, svc in client.wsdl.services.items():
                print(f"   Servicio: {svc_name}")
                for port_name, port in svc.ports.items():
                    ops = sorted(port.binding._operations.keys())
                    print(f"      Puerto: {port_name}")
                    print(f"      Operaciones: {', '.join(ops)}")
        
        # Forzar binding/port SOAP 1.2 espec√≠fico del servicio de consulta lote
        svc_name_selected = "de-ws-consultas-consuta-loteService"
        port_name_selected = "de-ws-consultas-consuta-loteSoap12"
        op_name = "rEnviConsLoteDe"
        
        # Verificar que el servicio y puerto existan
        if svc_name_selected not in client.wsdl.services:
            available_services = list(client.wsdl.services.keys())
            cleanup_pem_files()
            _die(f"Servicio '{svc_name_selected}' no encontrado en WSDL. Servicios disponibles: {available_services}")
        
        svc = client.wsdl.services[svc_name_selected]
        if port_name_selected not in svc.ports:
            available_ports = list(svc.ports.keys())
            cleanup_pem_files()
            _die(f"Puerto '{port_name_selected}' no encontrado en servicio '{svc_name_selected}'. Puertos disponibles: {available_ports}")
        
        port = svc.ports[port_name_selected]
        available_ops = sorted(port.binding._operations.keys())
        
        if op_name not in available_ops:
            cleanup_pem_files()
            _die(f"Operaci√≥n '{op_name}' no encontrada en puerto '{port_name_selected}'. Operaciones disponibles: {available_ops}")
        
        print(f"‚úÖ Usando operaci√≥n: {op_name} (servicio: {svc_name_selected}, puerto: {port_name_selected})")
        
        # --- Extraer endpoint SIEMPRE desde soap12:address/@location del WSDL local ---
        try:
            from lxml import etree
            
            # Extraer endpoint desde el WSDL local (wsdl_path es el Path real del archivo cargado)
            wsdl_root = etree.parse(str(wsdl_path)).getroot()
            ns = {"soap12": "http://schemas.xmlsoap.org/wsdl/soap12/"}
            hits = wsdl_root.xpath("//soap12:address/@location", namespaces=ns)
            if not hits:
                cleanup_pem_files()
                raise RuntimeError("No encontr√© soap12:address/@location en el WSDL local.")
            
            address = hits[0].strip()
            print(f"üåê Endpoint efectivo (desde WSDL): {address}")
            
            # Crear service apuntando al endpoint extra√≠do del WSDL
            service_def = client.wsdl.services[svc_name_selected]
            port_def = service_def.ports[port_name_selected]
            binding_qname = port_def.binding.name  # OJO: .name (QName), NO .qname
            
            service = client.create_service(binding_qname, address)
        except Exception as e:
            cleanup_pem_files()
            _die(f"Error al crear servicio: {e}")
        
        # Llamar operaci√≥n rEnviConsLoteDe con par√°metros directos
        try:
            # Intentar primero con keywords
            try:
                resp = service.rEnviConsLoteDe(dId=1, dProtConsLote=prot, dCDC=None)
            except (TypeError, Fault):
                # Si falla, intentar posicional
                resp = service.rEnviConsLoteDe(1, prot, None)
        except (Fault, Exception) as e:
            # En caso de error, si est√° en debug, imprimir request/response SOAP crudos
            if debug_enabled:
                print("\n‚ùå Error en llamada SOAP. Request/Response SOAP crudos:")
                try:
                    if hasattr(history, 'last_sent') and history.last_sent:
                        request_envelope = history.last_sent.get("envelope", None)
                        if request_envelope is not None:
                            # Si es un elemento XML, serializarlo
                            if hasattr(request_envelope, 'tag'):
                                from lxml import etree
                                print("\n--- REQUEST SOAP ---")
                                print(etree.tostring(request_envelope, pretty_print=True, encoding="unicode"))
                            elif isinstance(request_envelope, bytes):
                                print("\n--- REQUEST SOAP ---")
                                print(request_envelope.decode("utf-8", errors="ignore"))
                            else:
                                print("\n--- REQUEST SOAP ---")
                                print(str(request_envelope))
                except Exception as ex:
                    if debug_enabled:
                        print(f"‚ö†Ô∏è  Error al serializar request: {ex}")
                
                try:
                    if hasattr(history, 'last_received') and history.last_received:
                        response_envelope = history.last_received.get("envelope", None)
                        if response_envelope is not None:
                            # Si es un elemento XML, serializarlo
                            if hasattr(response_envelope, 'tag'):
                                from lxml import etree
                                print("\n--- RESPONSE SOAP ---")
                                print(etree.tostring(response_envelope, pretty_print=True, encoding="unicode"))
                            elif isinstance(response_envelope, bytes):
                                print("\n--- RESPONSE SOAP ---")
                                print(response_envelope.decode("utf-8", errors="ignore"))
                            else:
                                print("\n--- RESPONSE SOAP ---")
                                print(str(response_envelope))
                except Exception as ex:
                    if debug_enabled:
                        print(f"‚ö†Ô∏è  Error al serializar response: {ex}")
            
            cleanup_pem_files()
            _die(f"Error al llamar operaci√≥n {op_name}: {e}")
        
        # Parsear respuesta de Zeep
        try:
            # Convertir respuesta a dict
            resp_dict = {}
            try:
                resp_dict = serialize_object(resp)
            except Exception:
                pass
            
            if not resp_dict:
                if hasattr(resp, '__dict__'):
                    resp_dict = resp.__dict__
                elif isinstance(resp, dict):
                    resp_dict = resp
                else:
                    resp_dict = {"response": str(resp)}
            
            result_dict = resp_dict
            
        except Exception as e:
            cleanup_pem_files()
            _die(f"Error al parsear respuesta Zeep: {e}")
        finally:
            transport.session.close()
            
    except Exception as e:
        # WSDL/Zeep fall√≥ - usar fallback manual
        print(f"\n‚ö†Ô∏è  Zeep/WSDL fall√≥ ({e}), usando fallback manual...")
        fallback_used = True
        
        try:
            # Obtener endpoint directo con .wsdl
            if args.env == "prod":
                endpoint_url = "https://sifen.set.gov.py/de/ws/consultas/consulta-lote"
            else:
                endpoint_url = "https://sifen-test.set.gov.py/de/ws/consultas/consulta-lote"
            
            # Obtener certificado mTLS
            cert_tuple, temp_files, mode = _resolve_mtls(cert_path, key_or_password, is_pem_mode)
            
            # Llamar al fallback manual
            response_xml = _http_consulta_lote_manual(
                endpoint_url=endpoint_url,
                prot=prot,
                env=args.env,
                cert_tuple=cert_tuple,
                artifacts_dir=artifacts_dir
            )
            
            # Parsear XML de respuesta manual
            import xml.etree.ElementTree as ET
            # FIX: nunca pasar None a ET.fromstring
            if response_xml is None:
                response_xml = b""
            elif isinstance(response_xml, str):
                response_xml = response_xml.encode('utf-8','ignore')
            root = ET.fromstring(response_xml)

            # Extraer datos del XML SOAP
            # Namespace SIFEN
            sifen_ns = {"sifen": "http://ekuatia.set.gov.py/sifen/xsd"}
            
            # Buscar respuesta en el body
            resp_elem = root.find(".//sifen:rEnviConsLoteDeResponse", sifen_ns)
            if resp_elem is None:
                # Intentar sin prefijo
                resp_elem = root.find(".//rEnviConsLoteDeResponse")
            
            result_dict = {}
            if resp_elem is not None:
                # Extraer campos
                d_cod_res = resp_elem.find(".//sifen:dCodResLot", sifen_ns)
                d_msg_res = resp_elem.find(".//sifen:dMsgResLot", sifen_ns)
                g_res_proc = resp_elem.find(".//sifen:gResProcLote", sifen_ns)
                
                if d_cod_res is None:
                    d_cod_res = resp_elem.find(".//dCodResLot")
                if d_msg_res is None:
                    d_msg_res = resp_elem.find(".//dMsgResLot")
                if g_res_proc is None:
                    g_res_proc = resp_elem.find(".//gResProcLote")
                
                if d_cod_res is not None:
                    result_dict["dCodResLot"] = d_cod_res.text
                if d_msg_res is not None:
                    result_dict["dMsgResLot"] = d_msg_res.text
                if g_res_proc is not None:
                    # Parsear gResProcLote
                    items = []
                    for item in g_res_proc.findall(".//sifen:dId", sifen_ns):
                        items.append({"dId": item.text})
                    result_dict["gResProcLote"] = items
            else:
                # Si no se encuentra respuesta, guardar XML crudo
                                # Fallback: algunas respuestas (sobre todo errores) vienen como rRetEnviDe en vez de rEnviConsLoteDeResponse
                try:
                    # Asegurar root disponible
                    from lxml import etree as _lxml_etree
                    try:
                        _root = root  # noqa: F821
                    except NameError:
                        _root = None
                    # Si root existe pero no tiene xpath (xml.etree), reconstruir como lxml
                    if _root is None or not hasattr(_root, 'xpath'):
                        _root = _lxml_etree.fromstring(response_xml.encode('utf-8') if isinstance(response_xml, str) else response_xml)
                    root = _root

                    def _first_text(xpath_expr: str):
                        vals = root.xpath(xpath_expr)
                        if not vals:
                            return None
                        v = vals[0]
                        return (str(v).strip() if v is not None else None) or None
                
                    # Caso A (esperado): rEnviConsLoteDeResponse
                    resp_a = root.xpath('//*[local-name()="rEnviConsLoteDeResponse"]')
                    if resp_a:
                        # Dejar que el flujo existente siga (no tocar ac√°)
                        result_dict = {"raw_xml": response_xml}
                    else:
                        # Caso B (com√∫n en errores): rRetEnviDe
                        resp_b = root.xpath('//*[local-name()="rRetEnviDe"]')
                        if resp_b:
                            dFecProc = _first_text('//*[local-name()="dFecProc"]/text()')
                            dCodRes  = _first_text('//*[local-name()="dCodRes"]/text()')
                            dMsgRes  = _first_text('//*[local-name()="dMsgRes"]/text()')
                            result_dict = {
                                "raw_xml": response_xml,
                                "fallback_shape": "rRetEnviDe",
                                "dFecProc": dFecProc,
                                # Mapear a los nombres esperados por el resto del pipeline
                                "dCodResLot": dCodRes,
                                "dMsgResLot": dMsgRes,
                            }
                        else:
                            # Caso C (nuevo): rResEnviConsLoteDe
                            resp_c = root.xpath('//*[local-name()="rResEnviConsLoteDe"]')
                            if resp_c:
                                dFecProc = _first_text('//*[local-name()="dFecProc"]/text()')
                                dCodResLot = _first_text('//*[local-name()="dCodResLot"]/text()')
                                dMsgResLot = _first_text('//*[local-name()="dMsgResLot"]/text()')
                                result_dict = {
                                    "raw_xml": response_xml,
                                    "fallback_shape": "rResEnviConsLoteDe",
                                    "dFecProc": dFecProc,
                                    "dCodResLot": dCodResLot,
                                    "dMsgResLot": dMsgResLot,
                                }
                            else:
                                result_dict = {"raw_xml": response_xml, "parse_error": "No se encontr√≥ rEnviConsLoteDeResponse, rRetEnviDe ni rResEnviConsLoteDe"}
                except Exception as e:
                    result_dict = {"raw_xml": response_xml, "parse_error": f"Error parseando respuesta SOAP: {e}"}

            
            # Limpiar archivos temporales
            if mode == "P12" and temp_files:
                cleanup_pem_files(temp_files[0], temp_files[1])
                
        except Exception as fallback_error:
            # En caso de error en el fallback, generar JSON de error en lugar de abortar
            print(f"\n‚ö†Ô∏è  Error en fallback manual: {fallback_error}")
            print("‚ÑπÔ∏è  Generando JSON de error...")
            
            # Crear result_dict de error
            result_dict = {
                "error_type": type(fallback_error).__name__,
                "error_message": str(fallback_error),
                "fallback_used": True,
                "endpoint_tried": [endpoint_url],  # Lista de endpoints intentados
                "rc": 2  # rc=2 solo si no hay respuesta SOAP parseable
            }
            
            # Continuar con el flujo normal para generar JSON
    
    # Preparar timestamp para guardar archivos
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # Parsear respuesta (usar result_dict de Zeep o fallback)
    try:
        # Usar result_dict que ya viene de Zeep o del fallback
        resp_dict = result_dict or {}
        
        # Extraer campos principales
        result: Dict[str, Any] = {
            "ok": False,  # Usar 'ok' en lugar de 'success' para consistencia
            "dProtConsLote": prot,
            "response_dict": resp_dict,
            "fallback_used": fallback_used,
        }
        
        # Si hay error_type, es un resultado de error
        if "error_type" in resp_dict:
            result.update({
                "ok": False,
                "error_type": resp_dict.get("error_type"),
                "error_message": resp_dict.get("error_message"),
                "endpoint_tried": resp_dict.get("endpoint_tried", []),
                "rc": resp_dict.get("rc", 2)
            })
        else:
            # Respuesta SOAP exitosa (aunque pueda tener c√≥digo de error SIFEN)
            result["rc"] = 0  # rc=0 si hubo respuesta SOAP parseable
        
        # Buscar c√≥digo y mensaje en la respuesta (diferentes posibles nombres)
        codigo_respuesta = None
        mensaje = None
        
        # Buscar en diferentes campos posibles
        for key in ["dCodResLot", "dCodRes", "codigo", "code"]:
            if key in resp_dict:
                codigo_respuesta = str(resp_dict[key])
                break
        
        for key in ["dMsgResLot", "dMsgRes", "mensaje", "message", "msg"]:
            if key in resp_dict:
                mensaje = str(resp_dict[key])
                break
        
        # Si no se encontr√≥, buscar recursivamente
        def find_in_dict(d: Any, key: str) -> Optional[Any]:
            if isinstance(d, dict):
                if key in d:
                    return d[key]
                for v in d.values():
                    result = find_in_dict(v, key)
                    if result is not None:
                        return result
            elif isinstance(d, list):
                for item in d:
                    result = find_in_dict(item, key)
                    if result is not None:
                        return result
            return None
        
        if not codigo_respuesta:
            codigo_respuesta = find_in_dict(resp_dict, "dCodResLot") or find_in_dict(resp_dict, "dCodRes")
        if not mensaje:
            mensaje = find_in_dict(resp_dict, "dMsgResLot") or find_in_dict(resp_dict, "dMsgRes")
        
        if codigo_respuesta:
            result["dCodResLot"] = str(codigo_respuesta)
        if mensaje:
            result["dMsgResLot"] = str(mensaje)
        
        # Determinar √©xito seg√∫n c√≥digos SIFEN
        if codigo_respuesta in ("0361", "0362"):
            result["ok"] = True
            result["status"] = "ok"
            print("‚úÖ Consulta OK")
        elif codigo_respuesta == "0364":
            result["ok"] = True
            result["status"] = "requires_cdc"
            result["sin_detalle_por_lote"] = True
            print("‚ö†Ô∏è  Lote fuera de ventana 48h, se requiere consulta por CDC")
            
            # FALLBACK AUTOM√ÅTICO: Consultar cada CDC individualmente
            print("\n" + "="*70)
            print("FALLBACK AUTOM√ÅTICO: Consultando DE por CDC")
            print("="*70)
            
            # Obtener CDCs del lote
            cdcs = get_cdcs_for_lote(prot, artifacts_dir, debug_enabled)
            
            if not cdcs:
                print("\n‚ùå No se encontraron CDCs para el lote.")
                print("   Instrucci√≥n: Guarda los CDCs al enviar el lote para habilitar el fallback autom√°tico.")
                result["fallback_error"] = "No se encontraron CDCs para el lote"
            else:
                print(f"\nüìã CDCs encontrados: {len(cdcs)}")
                
                # Consultar cada CDC
                from app.sifen_client.soap_client import SoapClient
                from app.sifen_client.config import get_sifen_config
                
                config = get_sifen_config(env=args.env)
                client = SoapClient(config)
                
                resultados_cdc = []
                for idx, cdc in enumerate(cdcs, 1):
                    print(f"\nüîç Consultando CDC #{idx}/{len(cdcs)}: {cdc}")
                    try:
                        cdc_result = client.consulta_de_por_cdc_raw(cdc)
                        cdc_status = cdc_result.get("http_status", 0)
                        cdc_xml = cdc_result.get("raw_xml", "")
                        
                        # Parsear respuesta
                        cdc_cod_res = cdc_result.get("dCodRes", "N/A")
                        cdc_msg_res = cdc_result.get("dMsgRes", "N/A")
                        cdc_prot_aut = cdc_result.get("dProtAut", None)
                        
                        # Determinar estado
                        if cdc_cod_res in ("0200", "0300"):
                            estado = "Aprobado"
                        elif cdc_cod_res in ("0201", "0301"):
                            estado = "Rechazado"
                        else:
                            estado = "En proceso"
                        
                        resultado_cdc = {
                            "cdc": cdc,
                            "estado": estado,
                            "codigo": cdc_cod_res,
                            "mensaje": cdc_msg_res,
                            "dProtAut": cdc_prot_aut,
                            "http_status": cdc_status,
                        }
                        resultados_cdc.append(resultado_cdc)
                        
                        print(f"   Estado: {estado}")
                        print(f"   C√≥digo: {cdc_cod_res}")
                        print(f"   Mensaje: {cdc_msg_res}")
                        if cdc_prot_aut:
                            print(f"   dProtAut: {cdc_prot_aut}")
                        
                    except Exception as e:
                        print(f"   ‚ùå Error al consultar CDC {cdc}: {e}")
                        resultados_cdc.append({
                            "cdc": cdc,
                            "estado": "Error",
                            "codigo": "ERROR",
                            "mensaje": str(e),
                            "dProtAut": None,
                            "http_status": 0,
                        })
                
                # Guardar resumen
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                resumen_file = artifacts_dir / f"consulta_lote_0364_fallback_{timestamp}.json"
                resumen_data = {
                    "dProtConsLote": prot,
                    "codigo_respuesta": codigo_respuesta,
                    "mensaje": mensaje,
                    "cdcs_consultados": len(cdcs),
                    "resultados": resultados_cdc,
                }
                resumen_file.write_text(
                    json.dumps(resumen_data, ensure_ascii=False, indent=2, default=str),
                    encoding="utf-8"
                )
                print(f"\nüíæ Resumen guardado en: {resumen_file.name}")
                
                # Imprimir tabla resumen
                print("\n" + "="*70)
                print("RESUMEN POR CDC")
                print("="*70)
                print(f"{'CDC':<44} | {'Estado':<12} | {'C√≥digo':<8} | {'Mensaje':<30} | {'dProtAut'}")
                print("-" * 120)
                for r in resultados_cdc:
                    cdc_short = r["cdc"][:44] if len(r["cdc"]) > 44 else r["cdc"]
                    estado_short = r["estado"][:12] if len(r["estado"]) > 12 else r["estado"]
                    codigo_short = r["codigo"][:8] if len(r["codigo"]) > 8 else r["codigo"]
                    mensaje_short = r["mensaje"][:30] if len(r["mensaje"]) > 30 else r["mensaje"]
                    prot_aut = r["dProtAut"] or "N/A"
                    print(f"{cdc_short:<44} | {estado_short:<12} | {codigo_short:<8} | {mensaje_short:<30} | {prot_aut}")
                
                result["fallback_resultados"] = resultados_cdc
                result["fallback_resumen_file"] = str(resumen_file)
        else:
            result["status"] = "error"
            print("‚ùå Error en consulta")
        
        if codigo_respuesta:
            print(f"   C√≥digo: {codigo_respuesta}")
        if mensaje:
            print(f"   Mensaje: {mensaje}")
        
        # Buscar gResProcLote en la respuesta
        g_res_proc_lote = find_in_dict(resp_dict, "gResProcLote")
        if g_res_proc_lote and isinstance(g_res_proc_lote, list):
            print(f"\n   Documentos en lote: {len(g_res_proc_lote)}")
            for idx, de_res in enumerate(g_res_proc_lote, 1):
                if isinstance(de_res, dict):
                    de_id = de_res.get("dId", "N/A")
                    de_est_res = de_res.get("dEstRes", "N/A")
                    de_cod_res = de_res.get("dCodRes", "N/A")
                    de_msg_res = de_res.get("dMsgRes", "N/A")
                    print(f"   DE #{idx}: id={de_id}, estado={de_est_res}, c√≥digo={de_cod_res}")
                    if de_msg_res and de_msg_res != "N/A":
                        print(f"      mensaje: {de_msg_res}")
            result["gResProcLote"] = g_res_proc_lote
        
        # Guardar artifacts de respuesta (raw SOAP/XML) en artifacts/
        
        # Guardar XML de respuesta si est√° disponible (desde history plugin o fallback)
        if debug_enabled:
            if fallback_used and "raw_xml" in resp_dict:
                # Guardar XML del fallback
                response_xml = resp_dict["raw_xml"]
                fname = artifacts_dir / f"consulta_lote_response_{timestamp}.xml"
                fname.write_text(response_xml, encoding="utf-8")
                print(f"üíæ Artifact guardado (fallback): {fname.name}")
            elif not fallback_used and hasattr(history, 'last_received') and history.last_received:
                response_envelope = history.last_received.get('envelope', None)
                if response_envelope:
                    payload, ext = _artifact_bytes_from(response_envelope)
                    fname = artifacts_dir / f"consulta_lote_response_{timestamp}{ext}"
                    fname.write_bytes(_ensure_bytes(payload))
                    print(f"üíæ Artifact guardado: {fname.name}")
                    if ext != ".xml":
                        print("‚ö†Ô∏è  Respuesta no era XML serializable; guardada como texto (repr).")
        
        # Guardar request XML SIEMPRE (incluso sin debug) para dumps consistentes
        if not fallback_used and hasattr(history, 'last_sent') and history.last_sent:
            request_envelope = history.last_sent.get('envelope', None)
            if request_envelope:
                payload, ext = _artifact_bytes_from(request_envelope)
                fname = artifacts_dir / f"consulta_lote_sent_{timestamp}{ext}"
                fname.write_bytes(_ensure_bytes(payload))
                if debug_enabled:
                    print(f"üíæ Artifact guardado: {fname.name}")
                if ext != ".xml":
                    if debug_enabled:
                        print("‚ö†Ô∏è  Request no era XML serializable; guardada como texto (repr).")
        
        # Guardar headers SIEMPE (incluso sin debug)
        if hasattr(history, 'last_sent') and history.last_sent:
            sent_envelope = history.last_sent.get('envelope', None)
            if sent_envelope:
                # Guardar headers en formato JSON
                headers_data = {
                    "timestamp": timestamp,
                    "env": args.env,
                    "endpoint": "",
                    "headers": {
                        "Content-Type": f'application/soap+xml; charset=utf-8; action="{SIFEN_CONS_LOTE_ACTION}"',
                        "Accept": "application/soap+xml, text/xml, */*"
                    },
                    "dProtConsLote": prot
                }
                headers_path = artifacts_dir / f"consulta_lote_headers_sent_{timestamp}.json"
                try:
                    headers_path.write_text(json.dumps(headers_data, ensure_ascii=False, indent=2), encoding="utf-8")
                except Exception as e:
                    print(f"‚ö†Ô∏è  No se pudo guardar headers: {e}")
        
    except Exception as e:
        # En caso de error parsing, guardar JSON de error
        print(f"\n‚ö†Ô∏è  Error al parsear respuesta: {e}")
        print("‚ÑπÔ∏è  Generando JSON de error...")
        
        # Crear result de error
        result = {
            "ok": False,
            "dProtConsLote": prot,
            "error_type": type(e).__name__,
            "error_message": str(e),
            "fallback_used": fallback_used,
            "rc": 2
        }
        
        # Guardar respuesta JSON (incluso si es de error)
        if args.out:
            out_path = Path(args.out)
        else:
            # Guardar en artifacts/ con timestamp
            out_path = artifacts_dir / f"consulta_lote_{timestamp}.json"
        
        out_path.parent.mkdir(parents=True, exist_ok=True)
        out_path.write_text(
            json.dumps(result, ensure_ascii=False, indent=2, default=str),
            encoding="utf-8",
        )
        print(f"\nüíæ Respuesta JSON guardada en: {out_path}")
        
        cleanup_pem_files()
        return 0  # Siempre retornar 0 para que se guarde el JSON
    
    # Guardar respuesta JSON
    if args.out:
        out_path = Path(args.out)
    else:
        # Guardar en artifacts/ con timestamp
        out_path = artifacts_dir / f"consulta_lote_{timestamp}.json"
    
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(
        json.dumps(result, ensure_ascii=False, indent=2, default=str),
        encoding="utf-8",
    )
    print(f"\nüíæ Respuesta JSON guardada en: {out_path}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())


# USAGE
# =====
# # Configurar certificado
# export SIFEN_CERT_PATH="/ruta/al/certificado.p12"
#
# # Opci√≥n 1: Password desde env var
# export SIFEN_CERT_PASSWORD="tu_password"
# python -m tools.consulta_lote_de --env test --prot 47353168697315928
#
# # Opci√≥n 2: Password interactivo (m√°s seguro)
# python -m tools.consulta_lote_de --env test --prot 47353168697315928
# # (se pedir√° la contrase√±a sin mostrarla)
#
# # Con debug y output personalizado
# python -m tools.consulta_lote_de --env test --prot 47353168697315928 --debug --out /tmp/respuesta.json
