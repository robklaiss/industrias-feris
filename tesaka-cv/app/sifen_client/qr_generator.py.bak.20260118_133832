"""
Generador de QR oficial para SIFEN (gCamFuFD/dCarQR)

Implementación basada en el ejemplo oficial y KB de SIFEN.
El QR debe incluir todos los parámetros requeridos y el hash SHA256.

Ejemplo oficial:
https://ekuatia.set.gov.py/consultas-test/qr?nVersion=150&amp;Id=01000000019001001100005022020050710000000231&amp;dFeEmiDE=323032302d30352d30375431353a30333a3537&amp;dRucRec=00000002&amp;dTotGralOpe=2200000&amp;dTotIVA=200000&amp;cItems=2&amp;DigestValue=346b6f4a61715857704f6e64334971754d5331733776626e426149705973316435586a53572b6e337549343d&amp;IdCSC=0001&amp;cHashQR=67b07c782077eef44677e4d2f239cb111aea97d6f6ba177188eed0e06e6d3df9
"""
import hashlib
import binascii
from typing import Optional
from lxml import etree
import os
import logging

logger = logging.getLogger(__name__)

# Namespace SIFEN
SIFEN_NS = "http://ekuatia.set.gov.py/sifen/xsd"
# Namespace XMLDSig
DS_NS = "http://www.w3.org/2000/09/xmldsig#"


def build_qr_dcarqr(rde_xml: bytes, base_url: str = None, idcsc: str = None, csc: str = None) -> str:
    """
    Construye el QR oficial (dCarQR) para un DE firmado según Manual Técnico SIFEN v150 sección 13.8.4.
    
    Args:
        rde_xml: XML del rDE firmado (bytes)
        base_url: URL base para QR (default según ambiente)
        idcsc: IdCSC desde configuración
        csc: CSC desde configuración (secreto)
        
    Returns:
        URL completa del QR con todos los parámetros y hash
        
    Raises:
        ValueError: Si faltan datos requeridos o CSC
    """
    # Obtener configuración desde environment si no se provee
    if idcsc is None:
        idcsc = os.getenv("SIFEN_QR_IDCSC")
    if csc is None:
        csc = os.getenv("SIFEN_QR_CSC")
    if base_url is None:
        # Autodetectar ambiente según SIFEN_ENV
        sifen_env = os.getenv("SIFEN_ENV", "").lower()
        if "test" in sifen_env:
            base_url = "https://www.ekuatia.set.gov.py/consultas-test/qr"
        else:
            base_url = "https://www.ekuatia.set.gov.py/consultas/qr"
    
    # Validaciones críticas
    if not idcsc:
        raise ValueError("❌ ERROR CRÍTICO: Falta SIFEN_QR_IDCSC en environment")
    if not csc:
        raise ValueError("❌ ERROR CRÍTICO: Falta SIFEN_QR_CSC en environment (secreto)")
    
    # Parsear XML
    parser = etree.XMLParser(remove_blank_text=True)
    root = etree.fromstring(rde_xml, parser)
    
    # Namespace para XPath
    ns = {"s": SIFEN_NS, "ds": DS_NS}
    
    # Extraer datos requeridos del DE
    try:
        # 1. nVersion: valor de dVerFor (o default "150" si falta)
        dver_elem = root.xpath(".//s:dVerFor", namespaces=ns)
        n_version = dver_elem[0].text if dver_elem else "150"
        
        # 2. Id: atributo Id del nodo DE (CDC)
        de_elem = root.xpath(".//s:DE", namespaces=ns)[0]
        cdc = de_elem.get("Id")
        if not cdc:
            raise ValueError("DE no tiene atributo Id (CDC)")
        
        # 3. dFeEmiDE: texto de dFeEmiDE convertido a hex-ASCII lowercase
        fe_elem = root.xpath(".//s:dFeEmiDE", namespaces=ns)[0]
        fe_emision = fe_elem.text
        # Convertir a HEX ASCII (bytes UTF-8 del string)
        fe_emision_hex = binascii.hexlify(fe_emision.encode("utf-8")).decode("ascii")
        
        # 4. dRucRec: texto de dRucRec (solo dígitos; si viene con guion, quedarse con la parte numérica)
        ruc_rec_elem = root.xpath(".//s:dRucRec", namespaces=ns)
        if ruc_rec_elem:
            ruc_rec = ruc_rec_elem[0].text
            # Extraer solo dígitos
            ruc_rec = ''.join(filter(str.isdigit, ruc_rec))
        else:
            ruc_rec = "0"
        
        # 5. dTotGralOpe: buscar dTotGralOpe (si no existe usar "0")
        tot_gral_elem = root.xpath(".//s:dTotGralOpe", namespaces=ns)
        tot_gral = tot_gral_elem[0].text if tot_gral_elem else "0"
        
        # 6. dTotIVA: buscar dTotIVA (si no existe usar "0")
        tot_iva_elem = root.xpath(".//s:dTotIVA", namespaces=ns)
        tot_iva = tot_iva_elem[0].text if tot_iva_elem else "0"
        
        # 7. cItems: contar cantidad de gCamItem (si no existe usar "0")
        items = root.xpath(".//s:gCamItem", namespaces=ns)
        c_items = str(len(items))
        
        # 8. DigestValue: tomar el texto del primer DigestValue dentro de la firma
        # Convertir a hex-ASCII lowercase (NO base64-decode; convertir el texto base64 a hex de sus bytes)
        digest_elem = root.xpath(".//ds:DigestValue", namespaces=ns)[0]
        digest_value = digest_elem.text
        # Convertir el texto base64 a hex de sus bytes
        digest_hex = binascii.hexlify(digest_value.encode("ascii")).decode("ascii")
        
        # 9. IdCSC: idcsc (o SIFEN_QR_IDCSC)
        # Ya obtenido arriba
        
        logger.info(f"Datos extraídos para QR:")
        logger.info(f"  nVersion: {n_version}")
        logger.info(f"  CDC: {cdc}")
        logger.info(f"  Fecha emisión: {fe_emision} -> HEX: {fe_emision_hex}")
        logger.info(f"  RUC receptor: {ruc_rec}")
        logger.info(f"  Total general: {tot_gral}")
        logger.info(f"  Total IVA: {tot_iva}")
        logger.info(f"  Items: {c_items}")
        logger.info(f"  DigestValue: {digest_value} -> HEX: {digest_hex}")
        logger.info(f"  IdCSC: {idcsc}")
        
    except IndexError as e:
        raise ValueError(f"No se encontró elemento requerido en el XML: {e}")
    
    # Paso 1: Construir string de parámetros según orden exacto del Manual Técnico
    # nVersion=...&Id=...&dFeEmiDE=...&dRucRec=...&dTotGralOpe=...&dTotIVA=...&cItems=...&DigestValue=...&IdCSC=...
    params = {
        "nVersion": n_version,
        "Id": cdc,
        "dFeEmiDE": fe_emision_hex,
        "dRucRec": ruc_rec,
        "dTotGralOpe": tot_gral,
        "dTotIVA": tot_iva,
        "cItems": c_items,
        "DigestValue": digest_hex,
        "IdCSC": idcsc
    }
    
    # Orden exacto según especificación
    param_order = ["nVersion", "Id", "dFeEmiDE", "dRucRec", "dTotGralOpe", "dTotIVA", "cItems", "DigestValue", "IdCSC"]
    params_str = "&".join(f"{k}={params[k]}" for k in param_order)
    
    # Paso 2: concatenar al final el CSC secreto (sin separador)
    hash_input = params_str + csc
    
    # Paso3: Calcular hash SHA256
    c_hash_qr = hashlib.sha256(hash_input.encode("utf-8")).hexdigest()
    
    logger.info(f"String para hash: {params_str}[CSC_OCULTO]")
    logger.info(f"cHashQR calculado: {c_hash_qr}")
    
    # Paso 4: Construir URL final
    # TEST: https://www.ekuatia.set.gov.py/consultas-test/qr?
    # PROD: https://www.ekuatia.set.gov.py/consultas/qr?
    qr_url = f"{base_url}?{params_str}&cHashQR={c_hash_qr}"
    
    return qr_url


def inject_qr_into_gcamfufd(rde_elem: etree._Element, qr_url: str) -> None:
    """
    Inyecta el QR en gCamFuFD/dCarQR del rDE.
    Se asegura que gCamFuFD sea hijo directo de rDE (fuera de DE).
    
    Args:
        rde_elem: Elemento rDE ya parseado
        qr_url: URL del QR generada
    """
    ns = {"s": SIFEN_NS}
    
    # Buscar gCamFuFD como hijo directo de rDE (no dentro de DE)
    gcam = rde_elem.xpath("./s:gCamFuFD", namespaces=ns)
    if not gcam:
        # Crear gCamFuFD si no existe como hijo directo de rDE
        gcam = etree.SubElement(rde_elem, f"{{{SIFEN_NS}}}gCamFuFD")
    else:
        gcam = gcam[0]
    
    # Borrar hijos existentes de gCamFuFD (incluyendo dDesTrib si existe)
    for child in list(gcam):
        gcam.remove(child)
    
    # Insertar dCarQR
    dcar = etree.SubElement(gcam, f"{{{SIFEN_NS}}}dCarQR")
    dcar.text = qr_url
    
    # Insertar dInfAdic vacío (requerido por XSD)
    dinfo = etree.SubElement(gcam, f"{{{SIFEN_NS}}}dInfAdic")
    
    logger.info(f"QR inyectado en gCamFuFD/dCarQR (hijo directo de rDE)")


def generate_qr_for_rde(rde_xml: bytes, base_url: str = None, idcsc: str = None, csc: str = None) -> bytes:
    """
    Genera y agrega el QR a un rDE existente.
    
    Args:
        rde_xml: XML del rDE firmado
        base_url: URL base para QR
        idcsc: IdCSC
        csc: CSC
        
    Returns:
        XML con QR agregado (bytes)
    """
    # Generar QR
    qr_url = build_qr_dcarqr(rde_xml, base_url, idcsc, csc)
    
    # Parsear XML
    parser = etree.XMLParser(remove_blank_text=True)
    root = etree.fromstring(rde_xml, parser)
    
    # Encontrar rDE (puede ser root o anidado)
    rde = root if root.tag == f"{{{SIFEN_NS}}}rDE" else root.xpath(".//s:rDE", namespaces={"s": SIFEN_NS})[0]
    
    # Inyectar QR
    inject_qr_into_gcamfufd(rde, qr_url)
    
    # Serializar
    return etree.tostring(root, encoding="utf-8", xml_declaration=True)
