"""
Generador de QR oficial para SIFEN (gCamFuFD/dCarQR)

Implementación basada en el ejemplo oficial y KB de SIFEN.
El QR debe incluir todos los parámetros requeridos y el hash SHA256.

Ejemplo oficial:
https://ekuatia.set.gov.py/consultas-test/qr?nVersion=150&amp;Id=01000000019001001100005022020050710000000231&amp;dFeEmiDE=323032302d30352d30375431353a30333a3537&amp;dRucRec=00000002&amp;dTotGralOpe=2200000&amp;dTotIVA=200000&amp;cItems=2&amp;DigestValue=346b6f4a61715857704f6e64334971754d5331733776626e426149705973316435586a53572b6e337549343d&amp;IdCSC=0001&amp;cHashQR=67b07c782077eef44677e4d2f239cb111aea97d6f6ba177188eed0e06e6d3df9
"""
import hashlib
import binascii
from typing import Optional
from lxml import etree
import os
import logging

logger = logging.getLogger(__name__)

# Namespace SIFEN
SIFEN_NS = "http://ekuatia.set.gov.py/sifen/xsd"
# Namespace XMLDSig
DS_NS = "http://www.w3.org/2000/09/xmldsig#"


def build_qr_dcarqr(rde_xml: bytes, base_url: str = None, idcsc: str = None, csc: str = None) -> str:
    """
    Construye el QR oficial (dCarQR) para un DE firmado.
    
    Args:
        rde_xml: XML del rDE firmado (bytes)
        base_url: URL base para QR (default según ambiente)
        idcsc: IdCSC desde configuración
        csc: CSC desde configuración (secreto)
        
    Returns:
        URL completa del QR con todos los parámetros y hash
        
    Raises:
        ValueError: Si faltan datos requeridos o CSC
    """
    # Obtener configuración desde environment si no se provee
    if idcsc is None:
        idcsc = os.getenv("SIFEN_QR_IDCSC")
    if csc is None:
        csc = os.getenv("SIFEN_QR_CSC")
    if base_url is None:
        # Usar URL de test por defecto
        base_url = os.getenv("SIFEN_QR_BASE_URL", "https://ekuatia.set.gov.py/consultas-test/qr")
    
    # Validaciones críticas
    if not idcsc:
        raise ValueError("❌ ERROR CRÍTICO: Falta SIFEN_QR_IDCSC en environment")
    if not csc:
        raise ValueError("❌ ERROR CRÍTICO: Falta SIFEN_QR_CSC en environment (secreto)")
    
    # Parsear XML
    parser = etree.XMLParser(remove_blank_text=True)
    root = etree.fromstring(rde_xml, parser)
    
    # Namespace para XPath
    ns = {"s": SIFEN_NS, "ds": DS_NS}
    
    # Extraer datos requeridos del DE
    try:
        # 1. CDC (Id del DE)
        de_elem = root.xpath(".//s:DE", namespaces=ns)[0]
        cdc = de_elem.get("Id")
        if not cdc:
            raise ValueError("DE no tiene atributo Id (CDC)")
        
        # 2. dFeEmiDE (fecha de emisión)
        fe_elem = root.xpath(".//s:dFeEmiDE", namespaces=ns)[0]
        fe_emision = fe_elem.text
        # Convertir a HEX ASCII
        fe_emision_hex = binascii.hexlify(fe_emision.encode("ascii")).decode("ascii")
        
        # 3. dRucRec (RUC del receptor)
        ruc_rec_elem = root.xpath(".//s:dRucRec", namespaces=ns)[0]
        ruc_rec = ruc_rec_elem.text
        
        # 4. dTotGralOpe (total general de la operación)
        tot_gral_elem = root.xpath(".//s:dTotGralOpe", namespaces=ns)[0]
        tot_gral = tot_gral_elem.text
        
        # 5. dTotIVA (total IVA)
        tot_iva_elem = root.xpath(".//s:dTotIVA", namespaces=ns)[0]
        tot_iva = tot_iva_elem.text
        
        # 6. cItems (cantidad de items)
        # Contar gCamItem en gDtipDE/gCamItem
        items = root.xpath(".//s:gCamItem", namespaces=ns)
        c_items = str(len(items))
        
        # 7. DigestValue (de la firma)
        digest_elem = root.xpath(".//ds:DigestValue", namespaces=ns)[0]
        digest_value = digest_elem.text
        # Convertir a HEX ASCII
        digest_hex = binascii.hexlify(digest_value.encode("ascii")).decode("ascii")
        
        logger.info(f"Datos extraídos para QR:")
        logger.info(f"  CDC: {cdc}")
        logger.info(f"  Fecha emisión: {fe_emision} -> HEX: {fe_emision_hex}")
        logger.info(f"  RUC receptor: {ruc_rec}")
        logger.info(f"  Total general: {tot_gral}")
        logger.info(f"  Total IVA: {tot_iva}")
        logger.info(f"  Items: {c_items}")
        logger.info(f"  DigestValue: {digest_value} -> HEX: {digest_hex}")
        
    except IndexError as e:
        raise ValueError(f"No se encontró elemento requerido en el XML: {e}")
    
    # Construir parámetros (usando & normal, no &amp; todavía)
    params = {
        "nVersion": "150",
        "Id": cdc,
        "dFeEmiDE": fe_emision_hex,
        "dRucRec": ruc_rec,
        "dTotGralOpe": tot_gral,
        "dTotIVA": tot_iva,
        "cItems": c_items,
        "DigestValue": digest_hex,
        "IdCSC": idcsc
    }
    
    # Crear string de parámetros para hash (sin incluir cHashQR)
    # Orden exacto según especificación
    param_order = ["nVersion", "Id", "dFeEmiDE", "dRucRec", "dTotGralOpe", "dTotIVA", "cItems", "DigestValue", "IdCSC"]
    params_str = "&".join(f"{k}={params[k]}" for k in param_order)
    
    # Calcular hash SHA256
    # El hash es sobre params_str + CSC (sin la URL base)
    hash_input = params_str + csc
    c_hash_qr = hashlib.sha256(hash_input.encode("utf-8")).hexdigest()
    
    logger.info(f"String para hash: {params_str}[CSC_OCULTO]")
    logger.info(f"cHashQR calculado: {c_hash_qr}")
    
    # Construir URL final
    # En el XML final, los & se convierten a &amp; por escaping
    qr_url = f"{base_url}?{params_str}&cHashQR={c_hash_qr}"
    
    return qr_url


def inject_qr_into_gcamfufd(rde_elem: etree._Element, qr_url: str) -> None:
    """
    Inyecta el QR en gCamFuFD/dCarQR del rDE.
    
    Args:
        rde_elem: Elemento rDE ya parseado
        qr_url: URL del QR generada
    """
    ns = {"s": SIFEN_NS}
    
    # Buscar o crear gCamFuFD
    gcam = rde_elem.xpath("./s:gCamFuFD", namespaces=ns)
    if not gcam:
        # Crear gCamFuFD si no existe
        gcam = etree.Element(f"{{{SIFEN_NS}}}gCamFuFD")
        rde_elem.append(gcam)
    else:
        gcam = gcam[0]
    
    # Buscar o crear dCarQR
    dcar = gcam.xpath("./s:dCarQR", namespaces=ns)
    if not dcar:
        dcar = etree.SubElement(gcam, f"{{{SIFEN_NS}}}dCarQR")
    else:
        dcar = dcar[0]
    
    # Establecer el valor (lxml maneja el escaping de & a &amp;)
    dcar.text = qr_url
    
    logger.info(f"QR inyectado en gCamFuFD/dCarQR")


def generate_qr_for_rde(rde_xml: bytes, base_url: str = None, idcsc: str = None, csc: str = None) -> bytes:
    """
    Genera y agrega el QR a un rDE existente.
    
    Args:
        rde_xml: XML del rDE firmado
        base_url: URL base para QR
        idcsc: IdCSC
        csc: CSC
        
    Returns:
        XML con QR agregado (bytes)
    """
    # Generar QR
    qr_url = build_qr_dcarqr(rde_xml, base_url, idcsc, csc)
    
    # Parsear XML
    parser = etree.XMLParser(remove_blank_text=True)
    root = etree.fromstring(rde_xml, parser)
    
    # Encontrar rDE (puede ser root o anidado)
    rde = root if root.tag == f"{{{SIFEN_NS}}}rDE" else root.xpath(".//s:rDE", namespaces={"s": SIFEN_NS})[0]
    
    # Inyectar QR
    inject_qr_into_gcamfufd(rde, qr_url)
    
    # Serializar
    return etree.tostring(root, encoding="utf-8", xml_declaration=True)
